/**
 *  @constructor
 */
var TTable = function ( xmlAttributes )
{
  TTable.prototype.counter++ ;
  this._counter = TTable.prototype.counter ;
  this.jsClassName = "TTable" ;
  this.name = "TTable$" + this._counter ;
  this.selectedColumnIndex = -1 ;
  this.selectedTR = null ;
  this.selectedItem = null ;
  this.selectedCell = null ;
  this.selectMultiple = false ;
  this.wordWrap = false ;
  this.showHeader = true ;
  this.rowName = "row" ;
  this.getValuesAll = false ;
  this.getValuesChanged = false ;
  this.rowsPlain = false ;
  this._hasChanged = false ;
  this.dom = null ;
  this.selectable = true ;

  if (  typeof ( xmlAttributes ) == 'object'
     && xmlAttributes.tagName
     && xmlAttributes.tagName == "Table"
     )
  {
    this.xmlAttributes = xmlAttributes ;
    var s = this.xmlAttributes.getAttribute ( "name" ) ;
    if  ( s ) this.name = s ;
    this.resettable = this.xmlAttributes.getAttribute ( "reset" ) ;
    if ( this.resettable && this.resettable == 'true' ) this.resettable = true ;
    else                                                this.resettable = false ;
    this.sortable = this.xmlAttributes.getAttribute ( "sortable" ) ;
    if ( this.sortable && this.sortable == 'true' ) this.sortable = true ;
    else                                            this.sortable = false ;
    this.selectable = this.xmlAttributes.getAttribute ( "selectable" ) ;
    if ( this.selectable && this.selectable == 'false' ) this.selectable = false ;
    else                                                 this.selectable = true ;
    this.path = this.xmlAttributes.getAttribute ( "path" ) ;
    var rowName = this.xmlAttributes.getAttribute ( "row-name" ) ;
    if ( rowName ) this.rowName = rowName ;
    var multiple = this.xmlAttributes.getAttribute ( "multiple" ) ;
    this.selectMultiple = String  ( multiple ) == 'true' ? true : false ;
    var get_values = this.xmlAttributes.getAttribute ( "get-values" ) ;
    if ( get_values )
    {
      if ( get_values == "all" ) this.getValuesAll = true ;
      if ( get_values == "changed" ) this.getValuesChanged = true ;
    }
    else
    {
      var getValuesAll = this.xmlAttributes.getAttribute ( "getValuesAll" ) ;
      this.getValuesAll = String  ( getValuesAll ) == 'true' ? true : false ;
    }

    var s = this.xmlAttributes.getAttribute ( "show-header" ) ;
    if ( String ( s ) == 'false' ) this.showHeader = false ;
    this.rowsPlain = this.xmlAttributes.getAttribute ( "rows-plain" ) == 'true' ;
  }
  this.columnTypes = [] ;
  this.textAlign = [] ;
  this.mappings = [] ;
  this.mappingLists = [] ;
  this.itemListener = [] ;
  this.propertyChangeHandler = new PropertyChangeHandler() ;
  this.actionListener = [] ;
  this.selectionListener = [] ;
  this.keyListener = [] ;
  this.editable = [] ;
  this.editableWidth = [] ;
  this.mandatory = [] ;
  this.sortableList = [] ;
  this.anyEditable = false ;
  this.anyMandatory = false ;

  this.formats = [] ;

  this._flushed = false ;
  this.numberOfSelectedRows = 0 ;
  if ( this.selectable ) this.selectedRowClassName = "ThemeTableRowClassSelected" ;
  else                   this.selectedRowClassName = "ThemeTableRowClass" ;
  this.popupMenu = null ;
  this.popupMenuClass = PopupMenu ;
}
TTable.prototype =
{
  counter: 0,
  toString: function()
  {
    return "(" + this.jsClassName + ")["
//         + "id=" + this.dom.id
         + ",name=" + this.name
         + "]"
         ;
  },
  setName: function ( name )
  {
    if ( typeof ( name ) == 'string' ) this.name = name ;
  },
  hasChanged: function()
  {
    return this._hasChanged ;
  },
  setChanged: function ( state )
  {
    this._hasChanged = state ? true : false ;
  },
  layout: function ( dom, externalAttributes, nix, layoutContext )
  {
    this.dom = dom ;
    if ( ! this.xmlAttributes ) return ;
    this.dom.isFocusable = true ;
    if ( this.popupMenu ) this.dom.oncontextmenu = new Function("return false");
    var xml = new TXml ( this.xmlAttributes ) ;
    var columnNames = [] ;
    var columnTitles = [] ;
    this.columnTypes = [] ;
    this.textAlign = [] ;
    this.vAlign = [] ;
    this.mappings = [] ;
    this.mappingLists = [] ;
    this.editable = [] ;
    this.editableWidth = [] ;
    this.mandatory = [] ;
    this.sortableList = [] ;
    this.formats = [] ;
    var en = xml.getEnum ( "Columns", "Column" ) ;
    while ( en.hasNext() )
    {
      var x = en.next() ;
      var name = x.getAttribute ( "name" ) ;
      var title = x.getAttribute ( "title" ) ;
      if ( ! title ) title = name ;
      var type = x.getAttribute ( "type" ) ;
      var align = x.getAttribute ( "align" ) ;
      var valign = x.getAttribute ( "valign" ) ;
      var editable = x.getAttribute ( "editable" ) ;
      if ( editable == "choice" ) {}
      else
      if ( editable == "check" ) {}
      else
      if ( editable == "radio" ) {}
      else
      if ( editable == "text" ) {}
      else
      if ( editable == "textarea" )
      {
      }
      else editable = String ( editable ) == 'true' ? true : false ;

      this.editable.push ( editable ) ;
      if ( editable ) this.anyEditable = true ;
      var format = x.getAttribute ( "format" ) ;
      format = format ? format : false ;
      this.formats.push ( format ) ;

      var sortable = x.getAttribute ( "sortable" ) ;
      if ( typeof ( sortable ) != 'string' ) sortable = this.sortable ;
      else
      if ( sortable == 'false' ) sortable = false
      else
      if ( sortable == 'true' ) sortable = true
      this.sortableList.push ( sortable ) ;

      var editableWidth = x.getAttribute ( "width" ) ;
      editableWidth = parseInt ( editableWidth ) ;
      if ( isNaN ( editableWidth ) ) editableWidth = 0 ;
      this.editableWidth.push ( editableWidth ) ;

      var mandatory = x.getAttribute ( "mandatory" ) ;
      mandatory = mandatory ? mandatory : "" ;
      this.mandatory.push ( mandatory ) ;
      if ( mandatory ) this.anyMandatory = true ;

      if ( ! name ) name = title ;
      if ( ! name ) continue ;
      columnNames.push ( name ) ;
      if ( ! title ) title = " " ;
      columnTitles.push ( title ) ;
      this.columnTypes.push ( type ? type : "" ) ;
      this.textAlign.push ( align ) ;
      this.vAlign.push ( valign ) ;
      var xMappings = new TXml ( x ).getDom ( "Mappings" ) ;
      if ( ! xMappings )
      {
        this.mappings.push ( null ) ;
	this.mappingLists.push ( null ) ;
      }
      else
      {
        var mappingList = [] ;
        var hMap = this.getMappings ( xMappings, mappingList ) ;
        if ( hMap ) this.mappingLists.push ( mappingList ) ;
	else        this.mappingLists.push ( null ) ;
        this.mappings.push ( hMap ) ;
      }
    }
    this.setColumns ( columnNames, columnTitles ) ;

    var str = this.xmlAttributes.getAttribute ( "click" ) ;
    if ( ! str ) str = this.xmlAttributes.getAttribute ( "onclick" ) ;
    if ( str ) this._addSelectionListener ( new TFunctionExecutor ( str, layoutContext ) ) ;
    str = this.xmlAttributes.getAttribute  ( "dblclick" ) ;
    if ( ! str ) str = this.xmlAttributes.getAttribute ( "ondblclick" ) ;
    if ( str ) this._addActionListener ( new TFunctionExecutor ( str, layoutContext ) ) ;

    str = this.xmlAttributes.getAttribute  ( "onchange" ) ;
    if ( str )
    {
      var selectable = this.xmlAttributes.getAttribute ( "selectable" ) ;
      if ( this.selectable && this.xmlAttributes.getAttribute ( "selectable" ) != "true" )
      {
        this.selectable = false ;
        if ( this.selectable ) this.selectedRowClassName = "ThemeTableRowClassSelected" ;
        else                   this.selectedRowClassName = "ThemeTableRowClass" ;
      }
      this.addPropertyChangeListener ( new TFunctionExecutor ( str, layoutContext ) ) ;
    }

    this.xmlAttributes = null ;

    this.TABLE = document.createElement ( "table" ) ;
    this.TABLE.className = "ThemeTableClass" ;
    this.TABLE.xClassName = "Table" ;
    this.TABLE.border = 0 ;
    this.TABLE.cellSpacing = 0 ;
    this.TABLE.cellPadding = 2 ;
    if ( this.popupMenu ) this.TABLE.oncontextmenu = new Function("return false");
    if ( this.showHeader )
    {
      this.THEAD = document.createElement ( "thead" ) ;
      this.THEAD.className = "ThemeTableHeadClass" ;
    }
    this.TBODY = document.createElement ( "tbody" ) ;
    this.TBODY.className = "ThemeTableBodyClass" ;
this.TABLE.style.top = "0px" ;
    if ( TGui.isLTR() )
    {
      this.TABLE.style.left = "0px" ;
    }

    var TR = null ;
    if ( this.showHeader )
    {
      TR = document.createElement ( "tr" ) ;
      for ( i = 0 ; i < this.columnTitles.length ; i++ )
      {
        var TD = document.createElement ( "td" ) ;
        if ( ! this.columnTitles[i] ) this.columnTitles[i] = "." ;
        if ( this.columnTitles[i].indexOf ( "<" ) >= 0 && this.columnTitles[i].indexOf ( ">" ) > 0 )
        {
          var span = document.createElement ( "span" ) ;
          TD.appendChild ( span ) ;
          span.innerHTML = this.columnTitles[i] ;
	}
	else
        {
          TD.appendChild ( document.createTextNode ( this.columnTitles[i] ) ) ;
	}
        if ( ! this.wordWrap ) TD.style.whiteSpace = "nowrap" ;
        if ( this.sortableList[i] )
        {
          var img = document.createElement ( "img" ) ;
          var txml = Tango.getThemeXml ( "Arrow", "up" ) ;
          var w = txml.getIntAttribute ( "width", 11 ) ;
          var h = txml.getIntAttribute ( "height", 11 ) ;
          this.arrowUpImage = TGui.buildThemeImageUrl ( "Arrow", "up" ) ;
          img.style.width = w + "px" ;
          img.style.height = h + "px" ;
          img.style.marginLeft = 4 + "px" ;
          img.style.visibility = "hidden" ;
          img.src = this.arrowUpImage ;
          TD.appendChild ( img ) ;
          TD.arrowImage = img ;
        }
        TR.appendChild ( TD ) ;
      }
      TR.style.cursor = "default" ;
      this.THEAD.appendChild ( TR ) ;
      this.TABLE.appendChild ( this.THEAD ) ;
    }

    this.TABLE.appendChild ( this.TBODY ) ;
    TGui.addEventListener ( this.TABLE, "dblclick", this.mouseDoubleClicked.bindAsEventListener ( this ) ) ;
    TGui.addEventListener ( this.TABLE, "mousedown", this.mouseDown.bindAsEventListener ( this ) ) ;
    TGui.addEventListener ( this.TABLE, "mouseup", this.mouseUp.bindAsEventListener ( this ) ) ;
    this.dom.appendChild ( this.TABLE ) ; // XXXXX
    this.dom.style.padding = "0px" ;
    if ( TGui.isLTR() )
    {
      this.TABLE.style.left = "0px" ;
    }
    this.TABLE.style.top = TGui.getComputedStyleInt ( this.dom, "border-top", 0 ) + "px" ;
    this.TABLE.style.margin = "0px" ;
    this.TABLE.style.border = "0px" ;
//    TGui.addEventListener ( this.TABLE, "resize", this.setHeaderImages.bindAsEventListener ( this ) ) ;
    this._setHeaderImages() ;
    var xData = xml.get ( "Data" ) ;
    if ( xData )
    {
      this.setData ( xData ) ;
      xData.remove() ;
    }
    xml.flush() ;
  },
  setClassImages: function()
  {
    var txml = Tango.getThemeXml ( "Selected", "background" ) ;
    if ( txml ) this.selectedBackgroundImageExists = true ;
    else        this.selectedBackgroundImageExists = false ;
    this._setHeaderImages() ;
    this._setClassImagesRow() ;
  },
  _setHeaderImages: function()
  {
    if ( ! this.THEAD ) return ;
    this.THEAD.className = "" ;
    this.THEAD.className = "ThemeTableHeadClass" ;
    var TR = this.THEAD.firstChild ;
    if ( ! TR ) return ;
    var i = 0 ;
    for ( var ch = TR.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;
      if ( ch.nodeName != "TD" ) continue ;
      var w = ch.offsetWidth ;
      var h = ch.offsetHeight ;
      ch.style.backgroundImage = TGui.buildThemeBackgroundImageUrl ( "TableHeader", "normal", w, h ) ;
      ch.className = 'ThemeTableHeaderCellClass' ;
      if ( ! ch.listenerInstalled )
      {
        ch.listenerInstalled = true ;
        if ( this.sortableList[i] )
        {
          TGui.addEventListener ( ch, "mouseover", this.mouseOnHeader.bindAsEventListener ( this, "inside", ch, "mouseover", i ) ) ;
          TGui.addEventListener ( ch, "mouseout", this.mouseOnHeader.bindAsEventListener ( this, "normal", ch, "mouseout", i ) ) ;
          TGui.addEventListener ( ch, "mousedown", this.mouseOnHeader.bindAsEventListener ( this, "pressed", ch, "mousedown", i ) ) ;
          TGui.addEventListener ( ch, "mouseup", this.mouseOnHeader.bindAsEventListener ( this, "inside", ch, "mouseup", i ) ) ;
        }
      }
      i++ ;
    }
  },
  mouseOnHeader: function ( event, what, td, action, columnIndex )
  {
    td.style.backgroundImage = TGui.buildThemeBackgroundImageUrl ( "TableHeader", what, td.offsetWidth, td.offsetHeight ) ;
    if ( what == "inside" )
    {
      td.className = 'ThemeTableHeaderCellClassInside' ;
    }
    else
    if ( what == "normal" )
    {
      td.className = 'ThemeTableHeaderCellClass' ;
    }
    else
    if ( what == "pressed" )
    {
      td.className = 'ThemeTableHeaderCellClassPressed' ;
    }
    this.selectedColumnIndex = columnIndex
    if ( action == 'mouseup' )
    {
      if ( this.sortableList[columnIndex] )
      {
        var row = td.parentNode ;
        if ( this.columnTypes.length <= this.selectedColumnIndex ) return ;
        if ( ! this.sortedTR || ! this.sortedTR.sortedTD || this.sortedTR.sortedTD != td )
        {
          if ( this.sortedTR ) this.sortedTR.sortDirection = 0 ;
          this.sortedTR = row ;
          this.sortedTR.sortDirection = 1 ;
        }
        else
        {
          this.sortedTR.sortDirection *= -1 ;
        }
        this.sortColumn ( this.selectedColumnIndex ) ;

        if ( this.sortedTR.sortedTD )
        {
          this.sortedTR.sortedTD.arrowImage.style.visibility = "hidden" ;
        }
        if ( this.sortedTR.sortDirection == 1 )
        {
          td.arrowImage.style.visibility = "visible" ;
          td.arrowImage.src = TGui.buildThemeImageUrl ( "Arrow", "up" ) ;
        }
        if ( this.sortedTR.sortDirection == -1 )
        {
          td.arrowImage.style.visibility = "visible" ;
          td.arrowImage.src = TGui.buildThemeImageUrl ( "Arrow", "down" ) ;
        }
        this.sortedTR.sortedTD = td ;
      }
    }
  },
  setColumns: function ( columnNames, columnTitles )
  {
    if ( ! TSys.isArray ( columnNames ) )
    {
      throw "TTable: columnNames must be an array" ;
    }
    if ( columnNames.length == 0 )
    {
      throw "TTable: columnNames must not be empty" ;
    }
    if ( ! columnTitles )
    {
      columnTitles = columnNames ;
    }
    else
    {
      if ( ! TSys.isArray ( columnTitles ) )
      {
        throw "TTable: columnTitles must be an array" ;
      }
      if ( columnNames.length != columnTitles.length )
      {
        throw "TTable, setColumns: columnTitles must have the same length as columnNames" ;
      }
    }
    this.columnNames = columnNames ;
    this.column2Index = new Array() ;
    this.index2Column = new Array() ;
    if ( ! this.vAlign ) this.vAlign = [] ;
    var i ;
    for ( i = 0 ; i < columnNames.length ; i++ )
    {
      this.column2Index[columnNames[i]] = i ;
      this.index2Column[i] = columnNames[i] ;
    }
    this.columnTitles = columnTitles ;
  },
  onkeyup: function ( event )
  {
    this.fireKeyEvent ( event ) ;
  },
  onkeydown: function ( event )
  {
    var ev = new TEvent ( event ) ;
    if ( ev.isCursorUp() || ev.isCursorDown() )
    {
      if ( TSys.opera ) return ;
      this._handleCursorKeys ( ev ) ;
      return ;
    }
    this.fireKeyEvent ( event ) ;
  },
  onkeypress: function ( event )
  {
    var ev = new TEvent ( event ) ;
    if ( ev.isCursorUp() || ev.isCursorDown() )
    {
      if ( ! TSys.opera ) return ;
      this._handleCursorKeys ( ev ) ;
      return ;
    }
    if ( ev.isEnter() )
    {
      if ( ! this.selectedItem ) return ;
      var ev = new TActionEvent ( event, "ACTION" ) ;
      ev.setPeer ( this ) ;
      ev.setHtmlSource ( this.TABLE ) ;
      this.fireActionEvent ( ev ) ;
      return ;
    }
    this.fireKeyEvent ( event ) ;
  },
  _handleCursorKeys: function ( ev )
  {
    if ( ev.isCursorDown() && this.TBODY.firstChild )
    {
      this.selectedCell = null ;
      if ( ! this.selectedItem )
      {
        this._setSelected ( this.TBODY.firstChild, true ) ;
    this.dom.scrollTop = this.selectedItem.offsetTop ;
      }
      else
      {
        var nextSibling = this.selectedItem.nextSibling ;
        if ( nextSibling )
        {
          this._setSelected ( this.selectedItem, false ) ;
          this._setSelected ( nextSibling, true, true ) ;
    this.dom.scrollTop = this.selectedItem.offsetTop ;
        }
      }
    }
    else
    if ( ev.isCursorUp() && this.TBODY.firstChild )
    {
      this.selectedCell = null ;
      if ( ! this.selectedItem )
      {
        this._setSelected ( this.TBODY.lastChild, true ) ;
    this.dom.scrollTop = this.selectedItem.offsetTop ;
      }
      else
      {
        var nextSibling = this.selectedItem.previousSibling ;
        if ( nextSibling )
        {
          this._setSelected ( this.selectedItem, false ) ;
          this._setSelected ( nextSibling, true, true ) ;
    this.dom.scrollTop = this.selectedItem.offsetTop ;
        }
      }
    }
  },
  focusGained: function()
  {
    if ( typeof ( this._borderColor ) == 'undefined' ) this._borderColor = TGui.getComputedStyle ( this.dom, "border-Color" ) ;
    this.dom.className = "ThemeTableContainerFocused" ;
  },
  focusLost: function()
  {
    this.dom.className = "ThemeTableContainer" ;
  },
  clear: function()
  {
    this.removeAll() ;
  },
  reset: function()
  {
    if ( !this.resettable ) return ;
    this.removeAll() ;
  },
  getNumberOfRows: function()
  {
    return this.TBODY.lastChild ? this.TBODY.lastChild.sectionRowIndex + 1 : 0 ;
  },
  flush: function()
  {
    if ( this._flushed ) return ;
    this._flushed = true ;
    this.popupMenu = null ;
    this.popupMenuClass = null ;
    if ( this.THEAD )
    {
      var TR = this.THEAD.firstChild ;
      if ( TR )
      {
        for ( var ch = TR.firstChild ; ch ; ch = ch.nextSibling )
        {
          if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;
          if ( ch.nodeName != "TD" ) continue ;
          TGui.flushAttributes ( ch ) ;
        }
      }
    }
    for ( var i = 0 ; i < this.keyListener.length ; i++ )
    {
      this.keyListener[i].flush() ;
    }
    for ( var i = 0 ; i < this.selectionListener.length ; i++ )
    {
      this.selectionListener[i].flush() ;
    }
    for ( var i = 0 ; i < this.actionListener.length ; i++ )
    {
      this.actionListener[i].flush() ;
    }
    for ( var i = 0 ; i < this.itemListener.length ; i++ )
    {
      this.itemListener[i].flush() ;
    }
    this.propertyChangeHandler.flush() ;
    this.propertyChangeHandler = null ;
    this.actionListener.length = 0 ;
    this.keyListener.length = 0 ;
    this.selectionListener.length = 0 ;
    this.itemListener.length = 0 ;
    this.columnTypes.length = 0 ;
    this.textAlign.length = 0 ;
    this.vAlign.length = 0 ;
    this.mappings.length = 0 ;
    this.mappingLists.length = 0 ;
    this.editable.length = 0 ;
    this.editableWidth.length = 0 ;

    this.itemListener = null ;
    this.columnTypes = null ;
    this.textAlign = null ;
    this.formats.length = 0 ;
    this.vAlign = null ;
    this.mappings = null ;
    this.mappingLists = null ;
    this.actionListener = null ;
    this.selectionListener = null ;
    this.keyListener = null ;
    this.editable = null ;
    this.editableWidth = null ;
    this.removeAll() ;
  },
  setValues: function ( xml )
  {
    if ( typeof ( xml ) != 'object' ) throw "TTable.setValues(): invalid xml data: " + xml ;
    if ( ! this.path && ( ! this.name || this.name.indexOf ( "$" ) >= 0 ) )
    {
//      TSys.log ( "TTable.setValues(): table has no name: " + this.name ) ;
//      throw "TTable.setValues(): table has no name: " +this.name ;
      return ;
    }

    if ( ! xml )
    {
      this.removeAll() ;
      return ;
    }
    var x = xml ;
    if ( xml.jsClassName == "TXml" )
    {
    }
    else
    {
      x = new TXml ( xml ) ;
    }
    var xmlDom = null ;
    if ( this.path )
    {
      xmlDom = x.getDom ( this.path ) ;
    }
    if ( ! xmlDom )
    {
      xmlDom = x.getDom ( this.name ) ;
    }
    if ( ! xmlDom )
    {
      if ( x.getName() == this.name )
      {
        xmlDom = x.getDom() ;
      }
    }
    if ( xmlDom ) this.setData ( xmlDom ) ;
    else
    if ( this.rowsPlain )
    {
      this.setData ( x ) ;
    }
  },
  setData: function ( data )
  {
    if ( this.selectedItem )
    {
      var ev = new TEvent ( null, TEvent.prototype.ITEM_DESELECTED ) ;
      this.fireItemEvent ( ev ) ;
    }
    this.selectedItem = null ;
    this.selectedCell = null ;
    this._hasChanged = false ;
    if ( this.sortedTR )
    {
      this.sortedTR.sortDirection = 0 ;
      if ( this.sortedTR.sortedTD && this.sortedTR.sortedTD.arrowImage )
      {
        this.sortedTR.sortedTD.arrowImage.style.visibility = "hidden" ;
      }
      this.sortedTR = null ;
    }
    if ( this.dom )
    {
      this.dom.scrollTop = 0 ;
    }

    this.selectedColumnIndex = -1 ;
    if ( ! this.dom ) throw "TTable: setData: this.dom == null" ;
    if ( ! data )
    {
      this.removeAll() ;
      return ;
    }
    if ( typeof ( data ) == 'string' )
    {
      return ;
    }
    var dom = null ;
    if ( data.nodeName )
    {
      dom = data ;
    }
    else
    if ( data.jsClassName == "TXml" )
    {
      dom = data.getDom() ;
    }
    else
    {
      throw "TTable: setData: table data must be: html-string | xml-dom | TXml" ;
    }
    var first = false ;
    if ( ! this.TABLE )
    {
      first = true ;
      this.TABLE = document.createElement ( "table" ) ;
      this.TABLE.className = "ThemeTableClass" ;
      if ( this.showHeader )
      {
        this.THEAD = document.createElement ( "thead" ) ;
        this.THEAD.className = "ThemeTableHeadClass" ;
      }
      this.TBODY = document.createElement ( "tbody" ) ;
      this.TBODY.className = "ThemeTableBodyClass" ;

      var TR = null ;
      if ( this.showHeader )
      {
        TR = document.createElement ( "tr" ) ;
        for ( var i = 0 ; i < this.columnTitles.length ; i++ )
        {
          var TD = document.createElement ( "td" ) ;
          if ( ! this.columnTitles[i] ) this.columnTitles[i] = "." ;
          TD.appendChild ( document.createTextNode ( this.columnTitles[i] ) ) ;
          if ( ! this.wordWrap ) TD.style.whiteSpace = "nowrap" ;
          TR.appendChild ( TD ) ;
        }
        TR.style.cursor = "default" ;
        this.THEAD.appendChild ( TR ) ;
        this.TABLE.appendChild ( this.THEAD ) ;
      }
    }
    else
    {
      var ch = this.TBODY.firstChild ;
      while ( ch )
      {
        var ch1 = ch.nextSibling ;
        this.TBODY.removeChild ( ch ) ;
        ch = ch1 ;
      }
    }
    this.sortedTR = null ;
    var en = new TXEnum ( dom, this.rowName ) ;
    var columnValues = new Array() ;
    var columnVisibleText = new Array() ;
    var columnIsIcon = new Array() ;
    var n = 0 ;
    var TR = null ;
    var maxStrings = [] ;
    var editableComponents = [] ;
    var radioAndCheckboxNames = [] ;
    var eRowElements = new Array() ;
    for ( var i = 0 ; i < this.columnNames.length ; i++ )
    {
      maxStrings[i] = this.columnTitles[i] ;
      editableComponents[i] = [] ;
      radioAndCheckboxNames[i] = TSys.getTempId() ;
    }
    while ( en.hasNext() )
    {
      var eRow = en.next() ;
      var color = eRow.getAttribute ( "color" ) ;
      var bgcolor = eRow.getAttribute ( "background-color" ) ;
      var fontWeight = eRow.getAttribute ( "font-weight" ) ;

      TR = document.createElement ( "tr" ) ;
      TR.className = "ThemeTableRowClass" ;
      if ( color ) TR.style.color = color ;
      if ( bgcolor ) TR.style.backgroundColor = bgcolor ;
      if ( fontWeight )
      {
        TR.style.fontWeight = fontWeight ;
      }

      for ( var ch = eRow.firstChild ; ch ; ch = ch.nextSibling )
      {
        if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;

        var index = this.column2Index[ch.nodeName] ;
        if ( isNaN ( index ) ) continue ;
        eRowElements[index] = ch ;
        columnVisibleText[index] = ch.getAttribute ( "visibleText" ) ;
        var s = null ;
        if ( ch.firstChild && ch.firstChild.nodeValue )
        {
          columnValues[index] = String ( ch.firstChild.nodeValue ) ;
        }
        else
        {
          columnValues[index] = "" ;
        }

        if ( ! columnValues[index] && ! columnVisibleText[index] )
        {
          columnVisibleText[index] = "" ;
          columnValues[index] = "" ;
        }
        else
        if ( ! columnValues[index] )
        {
          columnValues[index] = columnVisibleText[index] ;
        }
        else
        if ( ! columnVisibleText[index] )
        {
          columnVisibleText[index] = columnValues[index] ;
        }
        if ( ch.getAttribute ( "isIcon" ) )
        {
          columnIsIcon[index] = true ;
          columnVisibleText[index] = "  " ;
        }
        var a = this.mappings[index] ;
        if ( a )
        {
          var as = a[columnVisibleText[index]] ;
          if ( as ) columnVisibleText[index] = as ;
        }
        if ( columnVisibleText[index].length > maxStrings[index].length )
        {
          maxStrings[index] = columnVisibleText[index] ;
        }
      }

      if ( n % 2 == 1 ) TR.className = "ThemeTableRowClassAlternate" ;

      n++ ;
      TR.originalIndex = n ;
      TR.domRow = eRow ;
      for ( var i = 0 ; i < columnValues.length ; i++ )
      {
        var eRowChild = eRowElements[i] ;
        var TD = document.createElement ( "td" ) ;
        TD.name = this.index2Column[i] ;
        if ( ! columnValues[i] ) columnValues[i] = "  " ;
        if ( ! columnVisibleText[i] ) columnVisibleText[i] = "  " ;
        if ( columnIsIcon[i] )
        {
          TD.innerHTML = "<img src='" + columnValues[i] + "' />" ;
        }
        else
        if ( this.editable[i] && this.editable[i] != 'textarea' )
        {
          if (  this.editable[i] == "check"
             || this.editable[i] == "checkbox"
             || this.editable[i] == "radio"
             )
          {
            var canEdit = true ;
            var disabledString = "" ;
            if ( eRowChild )
            {
              var a = eRowChild.getAttribute ( "editable" ) ;
              if ( a == "false" ) { canEdit = false ; disabledString = " disabled='true'" ; }
            }
            var eCB = null ;
            if ( TSys.isIE() )
            {
              var type = this.editable[i] ;
              if ( type != 'radio' ) type = 'checkbox' ;

              var a = this.mappings[i] ;
              var tt = columnVisibleText[i].trim() ;
              var str = columnValues[i] ;

              var val = null ;
              var def = null ;
              var checked = "" ;
              if ( a )
              {
                val = a["value"] ;
                def = a["default"] ;
                if ( tt == val ) checked = "checked" ;
              }
              if ( ! val ) val = "4" ;

              TD.innerHTML = "<input type='" + type +"' name='" + radioAndCheckboxNames[i] + "' value='" + val + "' " + disabledString + " " + checked + " ></input>" ;
              for ( var ee = TD.firstChild ; ee ; ee = ee.nextSibling )
              {
                if ( ee.nodeName == 'INPUT' )
                {
                  eCB = ee ;
                  break ;
                }
              }
              if ( def ) eCB.xDefaultValue = def ;
            }
            else
            {
              eCB = document.createElement ( "input" ) ;
              if ( this.editable[i] == "radio" )
              {
                eCB.type = 'radio' ;
                eCB.xClassName = "Radio" ;
              }
              else
              {
                eCB.type = 'checkbox' ;
                eCB.xClassName = "Checkbox" ;
              }
              TD.appendChild ( eCB ) ;
	      if ( ! canEdit ) eCB.disabled = true ;
              eCB.name = radioAndCheckboxNames[i] ;
              var a = this.mappings[i] ;
              var tt = columnVisibleText[i].trim() ;
              var str = columnValues[i] ;
              if ( a )
              {
                var val = a["value"] ;
                var def = a["default"] ;
                if ( val ) eCB.value = val ;
                if ( def ) eCB.xDefaultValue = def ;
                if ( tt == val ) eCB.checked = true ;
              }
              else
              {
                eCB.value = str ;
              }
            }
            TD.xInput = eCB ;
            if ( TSys.isIE() )
            {
              TGui.addEventListener ( eCB, "click", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
            }
	    else
            {
              TGui.addEventListener ( eCB, "change", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
            }
          }
          else
          if ( this.editable[i] == "choice" )
          {
            var canEdit = true ;
            if ( eRowChild )
            {
              var a = eRowChild.getAttribute ( "editable" ) ;
              if ( a == "false" ) canEdit = false ;
            }
            var eCH = document.createElement ( "SELECT" ) ;
            eCH.name = this.columnNames[i] ;
            eCH.xClassName = "Choice" ;
            TD.appendChild ( eCH ) ;
	    if ( ! canEdit ) eCH.disabled = true ;
            TD.xInput = eCH ;
            eCH.className = 'ThemeChoice' ;
            eCH.mandatory = this.mandatory[i] ;
            if ( this.editableWidth[i] ) eCH.style.width = this.editableWidth[i] + "px" ;
            var a = this.mappings[i] ;
            if ( a )
            {
              var ml = this.mappingLists[i] ;
              var ii = 0 ;
              for ( var iii = 0 ; iii < ml.length ; iii++ )
              {
                var key = ml[iii] ;
                var val = a[key] ;
                if ( typeof ( val ) != 'string' ) continue ;
                if ( columnValues[i] == key )
                {
                  eCH.options[ii++] = new Option ( val, key, true, true );
                }
                else
                {
                  eCH.options[ii++] = new Option ( val, key, false, false );
                }
              }
            }
            TGui.addEventListener ( eCH, "change", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
          }
          else
          if ( this.editable[i] == true || this.editable[i] == "text" )
          {
            var a  = null ;
            var canEdit = true ;
            if ( eRowChild )
            {
              a = eRowChild.getAttribute ( "type" ) ;
              if ( a ) tempType = a ;
              a = eRowChild.getAttribute ( "editable" ) ;
              if ( a == "false" ) canEdit = false ;
            }
            if ( ! canEdit )
            {
              if ( columnVisibleText[i].indexOf  ( '<' ) >= 0 )
              {
                TD.innerHTML = columnVisibleText[i] ;
              }
              else
              if ( columnVisibleText[i].indexOf  ( '\n' ) >= 0 )
              {
                columnVisibleText[i] = columnVisibleText[i].trim() ;
                if ( columnVisibleText[i].indexOf  ( '\n' ) >= 0 )
                {
                  var str = columnVisibleText[i].replace ( /\n/g, "<br/>" ) ;
                  TD.innerHTML = str ;
                }
                else
                {
                  TD.appendChild ( document.createTextNode ( columnVisibleText[i] ) ) ;
                }
              }
              else
              {
                TD.appendChild ( document.createTextNode ( columnVisibleText[i] ) ) ;
              }
              var t = this.columnTypes[i] ;
              if ( t == "money" || t == 'float' || t == 'int' )
              {
                TD.style.textAlign = 'right' ;
              }
            }
            else
            {
              var eTF = document.createElement ( "INPUT" ) ;
              editableComponents[i].push ( eTF ) ;
              eTF.type = 'text' ;
              eTF.name = this.columnNames[i] ;
              eTF.xClassName = "TextField" ;
              eTF.value = columnVisibleText[i].trim() ;
              TD.appendChild ( eTF ) ;
              TD.xInput = eTF ;
              eTF.className = 'ThemeTextField' ;
              eTF.mandatory = this.mandatory[i] ;
              if ( this.editableWidth[i] ) eTF.style.width = this.editableWidth[i] + "px" ;
              if ( eTF.mandatory ) TGui.setMandatoryDecoration ( eTF ) ;
              var tempType = this.columnTypes[i] ;
              if ( tempType == "int" )
              {
                eTF.style.textAlign = 'right' ;
                eTF.xType = "int" ;
                TGui.addEventListener ( eTF, "keyup", TGui.checkInput.bindAsEventListener ( TGui ) ) ;
                if ( this.mandatory[i] ) TGui.addEventListener ( eTF, "keyup", TGui.checkMandatory ) ;
              }
              else
              if ( tempType == "float" )
              {
                TD.dir = "ltr" ;
                eTF.style.textAlign = 'right' ;
                eTF.extendedType = "float" ;
                TGui.addEventListener ( eTF, "keyup", TGui.checkInput.bindAsEventListener ( TGui ) ) ;
                if ( this.mandatory[i] ) TGui.addEventListener ( eTF, "keyup", TGui.checkMandatory ) ;
              }
              else
              if ( eTF.mandatory )
              {
                TGui.addEventListener ( eTF, "keyup", TGui.checkMandatory ) ;
              }
              TGui.addEventListener ( eTF, "keyup", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
            }
          }
        }
        else
        if ( this.columnTypes[i] == "date" )
        {
          columnValues[i] = columnValues[i].trim() ;
          if ( ! columnValues[i] )
          {
            TD.appendChild ( document.createTextNode ( "" ) ) ;
          }
          else
          {
            TD.appendChild ( document.createTextNode ( DateUtils.formatDateShort ( DateUtils.stringToDate ( columnValues[i] ) ) ) ) ;
          }
        }
        else
        if ( this.columnTypes[i] == "datetime" )
        {
          columnValues[i] = columnValues[i].trim() ;
          if ( ! columnValues[i] )
          {
            TD.appendChild ( document.createTextNode ( "" ) ) ;
          }
          else
          {
            TD.appendChild ( document.createTextNode ( DateUtils.formatDateTimeShort ( DateUtils.stringToDate ( columnValues[i] ) ) ) ) ;
          }
        }
        else
        if ( this.columnTypes[i] == "float" )
        {
          var cv = columnValues[i].trim() ;
          if ( ! cv )
          {
/*
            if ( this.formats[i] )
            {
              cv = this.formats[i].sprintf ( 0 ) ;
              if ( cv.indexOf ( ' ' ) >= 0 ) cv = cv.replace ( / /g, "&nbsp;" ) ;
              TD.innerHTML = cv ;
	    }
*/
          }
          else
          {
            if ( this.formats[i] )
            {
              var d = parseFloat ( cv ) ;
              cv = this.formats[i].sprintf ( d ) ;
//              TD.appendChild ( document.createTextNode ( cv ) ) ;
              if ( cv.indexOf ( ' ' ) >= 0 ) cv = cv.replace ( / /g, "&nbsp;" ) ;
              TD.innerHTML = cv ;
	    }
	    else
	    {
              TD.appendChild ( document.createTextNode ( TSys.formatFloat ( cv ) ) ) ;
	    }
          }
          TD.dir = "ltr" ;
        }
        else
        if ( this.columnTypes[i] == "money" )
        {
          columnValues[i] = columnValues[i].trim() ;
          if ( ! columnValues[i] )
          {
//            TD.appendChild ( document.createTextNode ( TSys.formatMoneyWithCurrency ( 0 ) ) ) ;
          }
          else
          {
            TD.appendChild ( document.createTextNode ( TSys.formatMoneyWithCurrency ( columnValues[i] ) ) ) ;
          }
          TD.dir = "ltr" ;
        }
        else
        if ( columnVisibleText[i].indexOf  ( '<' ) >= 0 )
        {
          TD.innerHTML = columnVisibleText[i] ;
          if ( this.editable[i] == 'textarea' ) TD.editableTextArea = true ;
        }
        else
        if ( columnVisibleText[i].indexOf  ( '\n' ) >= 0 )
        {
          columnVisibleText[i] = columnVisibleText[i].trim() ;
          if ( columnVisibleText[i].indexOf  ( '\n' ) >= 0 )
          {
            var str = columnVisibleText[i].replace ( /\n/g, "<br/>" ) ;
            TD.innerHTML = str ;
          }
          else
          {
            TD.appendChild ( document.createTextNode ( columnVisibleText[i] ) ) ;
          }
          if ( this.editable[i] == 'textarea' ) TD.editableTextArea = true ;
        }
        else
        {
          TD.appendChild ( document.createTextNode ( columnVisibleText[i] ) ) ;
          if ( this.editable[i] == 'textarea' ) TD.editableTextArea = true ;
        }
        if ( ! this.editable[i] )
        {
          var t = this.columnTypes[i] ;
          if ( t == "money" || t == 'float' || t == 'int' )
          {
            TD.style.textAlign = 'right' ;
          }
        }
        TR.appendChild ( TD ) ;
        TR.style.cursor = "pointer" ;
        TD.className = "ThemeTableCellClass" ;
        if ( ! this.wordWrap ) TD.style.whiteSpace = "nowrap" ;
        if ( this.textAlign.length > i && this.textAlign[i] ) TD.style.textAlign = this.textAlign[i] ;
        if ( this.vAlign.length > i && this.vAlign[i] ) TD.style.verticalAlign = this.vAlign[i] ;
        columnValues[i] = null ;
        columnIsIcon[i] = false ;
        columnVisibleText[i] = null ;
        eRowElements[i] = null ;
      }
      this.TBODY.appendChild ( TR ) ;
    }
    if ( first )
    {
      this.TABLE.appendChild ( this.TBODY ) ;
      TGui.addEventListener ( this.TABLE, "dblclick", this.mouseDoubleClicked.bindAsEventListener ( this ) ) ;
      TGui.addEventListener ( this.TABLE, "mousedown", this.mouseDown.bindAsEventListener ( this ) ) ;
      TGui.addEventListener ( this.TABLE, "mouseup", this.mouseUp.bindAsEventListener ( this ) ) ;
      this.dom.appendChild ( this.TABLE ) ;
      this.dom.style.padding = "0px" ;
      if ( TGui.isLTR() )
      {
        this.TABLE.style.left = "0px" ;
      }
      this.TABLE.style.top = TGui.getComputedStyleInt ( this.dom, "border-top", 0 ) + "px" ;
      this.TABLE.style.margin = "0px" ;
      this.TABLE.style.border = "0px" ;
    }
    else
    {
      this.TABLE.style.visibility = "hidden" ;
      this.TABLE.style.visibility = "inherit" ;
    }
    {
      var body = document.getElementsByTagName ( "body" )[0] ;
      var span = document.createElement ( "span" ) ;
      span.style.padding = "0px" ;
      span.style.margin = "0px" ;
      body.appendChild ( span ) ;
      span.innerHTML = "&nbsp;" ;

      var first = true ;
      for ( var i = 0 ; i < this.editable.length ; i++ )
      {
        if ( this.editable[i] && this.editable[i] != "choice" )
        {
          if ( ! this.columnTypes[i] && ! this.editableWidth[i] )
          {
            if ( first )
            {
              var a = editableComponents[i] ;
              if ( a[0] )
              {
                var fontSize = TGui.getComputedStyle ( a[0], "font-size" ) ;
                var fontWeight = TGui.getComputedStyle ( a[0], "font-weight" ) ;
                var fontFamily = TGui.getComputedStyle ( a[0], "font-family" ) ;
                if ( fontSize ) span.style.fontSize = fontSize ;
                if ( fontWeight ) span.style.fontWeight = fontWeight ;
                if ( fontFamily ) span.style.fontFamily = fontFamily ;
                first = false ;
              }
            }
            span.innerHTML = maxStrings[i] ;
            var w = span.offsetWidth ; //+ 2 * TGui.M_width ;
            var a = editableComponents[i] ;
            for ( var j = 0 ; j < a.length ; j++ )
            {
              a[j].style.width = w + "px" ;
              if ( fontSize ) a[j].style.fontSize = fontSize ;
              if ( fontWeight ) a[j].style.fontWeight = fontWeight ;
              if ( fontFamily ) a[j].style.fontFamily = fontFamily ;
              a[j] = null ;
            }
            a.length = 0 ;
            editableComponents[i] = null ;
          }
        }
      }
      maxStrings.length = 0 ;
      editableComponents.length = 0 ;
      body.removeChild ( span ) ;
    }
    this._setHeaderImages() ;
    this._setClassImagesRow() ;
  },
  mouseUp: function ( event )
  {
    if ( this.currentTextArea && !this.currentTextAreaFocusDone  )
    {
      this.currentTextArea.focus() ;
      this.currentTextAreaFocusDone = true ;
      return ;
    }
    if ( this.popupMenu )
    {
      var ev = new TEvent ( event ) ;
      var src = ev.getSource() ;
      var TD = src ;
      var TR = src.parentNode ;
      if ( TR.nodeName.toUpperCase() == "TD" )
      {
        TD = TR ;
        TR = TR.parentNode ;
      }
      var tbody = TR.parentNode ;
      if ( tbody.nodeName.toUpperCase() == "TBODY" )
      {
        if ( ev.isButtonRight()
           || ( ev.isButtonLeft() && ev.isAlt() )
           || ( ev.isButtonLeft() && ev.isShift() )
           )
        {
          if ( tbody.nodeName.toUpperCase() == "THEAD" )
          {
            return ;
          }
          else
          {
            var pm = new this.popupMenuClass ( this.popupMenu, TD ) ;
            pm.show ( event ) ;
          }
        }
      }
    }
    if ( this.selectMultiple )
    {
      var ev = new TEvent ( event ) ;
      if ( ev.isCtrl() ) return ;
      if ( ev.isShift() ) return ;
      this.getNumberOfSelectedItems() ;
      if ( this.numberOfSelectedRows > 1 )
      {
        this.deselectAll() ;
        this.mouseDown ( event ) ;
      }
    }
  },
  mouseDown: function ( event )
  {
    var ev = new TEvent ( event ) ;
    if ( ev.getButton() == 3 ) ev.consume() ;
    ev.setPeer ( this ) ;
    var src = ev.getSource() ;

    if ( ! src )
    {
      ev.flush() ;
      return ;
    }
    var TD = src ;
    var TR = src.parentNode ;
    if ( ! TR )
    {
      ev.flush() ;
      return ;
    }
    this.selectedCell = null ;
    if ( TR.nodeName.toUpperCase() == "TD" )
    {
      TD = TR ;
      TR = TR.parentNode ;
    }
    var tbody = TR.parentNode ;
    this.selectedColumnIndex = -1 ;

    var en = new TXEnum ( TR, "td" ) ;
    while ( en.hasNext() )
    {
      this.selectedColumnIndex++ ;
      var th = en.next() ;
      if ( th == TD )
      {
        break ;
      }
    }
    if ( tbody.nodeName.toUpperCase() == "THEAD" )
    {
      return ;
    }

    if ( tbody.nodeName.toUpperCase() != "TBODY" ) return ;

    this.selectedCell = TD ;
    if ( TD.editableTextArea )
    {
      if ( TD.currentTextArea ) return ;
      if ( this.currentTextArea )
      {
        this._saveCurrentTextArea( true ) ;
        return ;
      }
      var w = TD.offsetWidth > 100 ? TD.offsetWidth : 100 ;
      var h = TD.offsetHeight > 100 ? TD.offsetHeight : 100 ;
      var xv = new TXml ( TD.parentNode.domRow ) ;
      var v = xv.getContent ( TD.name ) ;
      v = v.replace ( /<BR>/g, "\n" ).replace ( /<br>/g, "\n" ) ;
      while ( TD.firstChild )
      {
        TD.removeChild ( TD.firstChild ) ;
      }
      this.currentTextArea = document.createElement ( "TEXTAREA" ) ;
      TD.appendChild ( this.currentTextArea ) ;
      TD.currentTextArea = this.currentTextArea ;
      this.currentTextArea.className = "ThemeTextArea" ;
      this.currentTextArea.style.top = "0px" ;
      this.currentTextArea.style.left = "0px" ;
      this.currentTextArea.style.width = w + "px" ;
      this.currentTextArea.style.height = h + "px" ;
      this.currentTextArea.value = v ;
      TGui.addEventListener ( this.currentTextArea, "keydown", this._editableComponentStateChanged.bindAsEventListener ( this ) ) ;
      TGui.addEventListener ( this.currentTextArea, "keyup", this._editableComponentStateChanged.bindAsEventListener ( this ) ) ;
      TGui.addEventListener ( this.currentTextArea, "blur", this._editableComponentStateChanged.bindAsEventListener ( this ) ) ;
      this.currentTextAreaFocusDone = false ;
      this._setHeaderImages() ;
      this._setClassImagesRow() ;
      this.currentTextArea.TD = TD ;
      TD.appendChild ( document.createElement ( "br" ) ) ;
      var span = document.createElement ( "span" ) ;
      TD.appendChild ( span ) ;
      var img = document.createElement ( "img" ) ;
      span.style.width = "100%" ;
      span.appendChild ( img ) ;
      img.style.width = "16px" ;
      img.style.height = "16px" ;
      img.src = TGui.buildThemeImageUrl ( "Misc", "ok" ) ;
      TGui.addEventListener ( img, "mousedown", this._textareaOkMouseDown.bindAsEventListener ( this ) ) ;
      img = document.createElement ( "img" ) ;
      span.appendChild ( img ) ;
      img.style.width = "16px" ;
      img.style.height = "16px" ;
      img.src = TGui.buildThemeImageUrl ( "Misc", "edit-cancel" ) ;
      TGui.addEventListener ( img, "mousedown", this._textareaCancelMouseDown.bindAsEventListener ( this ) ) ;
      return ;
    }
    if ( this.selectMultiple )
    {
      if ( ev.isCtrl() )
      {
      }
      else
      if ( ev.isShift() )
      {
      }
      else
      {
        this.getNumberOfSelectedItems() ;
        if ( this.numberOfSelectedRows > 1 ) return ;
        this.deselectAll() ;
      }
    }
    else
    {
      this.deselectAll() ;
    }

    if ( this.selectMultiple && ev.isShift() )
    {
      var firstIndex = -1 ;
      var firstRow = null ;
      var rowIndex = -1 ;
      var lastIndex = -1 ;
      var lastRow = null ;

      this.selectedItem = TR ;

      var r = this.TBODY.firstChild ;
      var index = 0 ;
      while ( r )
      {
        if ( r.nodeType != DOM_ELEMENT_NODE )
        {
          r = r.nextSibling ;
          continue ;
        }
        if ( r === TR ) rowIndex = index ;
        if ( r.selected )
        {
          firstRow = r ;
          firstIndex = index ; break ;
        }
        index++ ;
        r = r.nextSibling ;
      }
      if ( r )
      {
        while ( r )
        {
          if ( r.nodeType != DOM_ELEMENT_NODE )
          {
            r = r.nextSibling ;
            continue ;
          }
          if ( r == TR ) rowIndex = index ;
          if ( r.selected )
          {
            lastRow = r ;
            lastIndex = index ;
          }
          index++ ;
          r = r.nextSibling ;
        }
      }
      this.deselectAll() ;
      if ( rowIndex == -1 ) TR.index ;
      if ( firstIndex == -1 && lastIndex == -1 )
      {
        this._selectItems ( this.TBODY.firstChild, TR ) ;
      }
      else
      if ( firstIndex >= 0 && rowIndex >= firstIndex )
      {
        this._selectItems ( firstRow, TR ) ;
      }
      else
      if ( firstIndex >= 0 && rowIndex <= firstIndex )
      {
        this._selectItems ( TR, lastRow ) ;
      }
      this.selectedItem = TR ;
      ev.setType ( TEvent.prototype.ITEM_SELECTED ) ;
      try
      {
        this.fireSelectionEvent ( ev ) ;
        this.fireItemEvent ( ev ) ;
      }
      finally
      {
        ev.flush() ;
      }
    }
    else
    {
      if ( TR.selected )
      {
        if ( this.selectMultiple && ev.isCtrl() )
        {
          this._setSelected ( TR, false, true )
        }
        else
        {
          this._setSelected ( TR, true, true )
        }
      }
      else
      {
        this._setSelected ( TR, true, true )
      }
    }
  },
  _setSelected: function ( TR, state, fireSelectionEvent )
  {
    state = state ? true : false ;

    if ( TR.selected == state ) return ;

    if ( state )
    {
      TR.className = this.selectedRowClassName ;
      TR.selected = true ;
      this.selectedItem = TR ;
      if ( this.selectedBackgroundImageExists )
      {
//        TR.style.backgroundColor = "transparent" ;
        TR.style.backgroundImage = TGui.buildThemeBackgroundImageUrl ( "Selected", "background", TR.offsetWidth, TR.offsetHeight ) ;
      }
      var ev = new TEvent ( null, TEvent.prototype.ITEM_SELECTED ) ;
      ev.setPeer ( this ) ;
      ev.setHtmlSource ( this.TABLE ) ;
      this.fireItemEvent ( ev ) ;
      if ( fireSelectionEvent ) this.fireSelectionEvent ( ev ) ;
    }
    else
    {
      if ( TR.sectionRowIndex % 2 == 1 ) TR.className = "ThemeTableRowClassAlternate" ;
      else                               TR.className = "ThemeTableRowClass" ;
      TR.selected = false ;
      this.selectedItem = null ;
      if ( this.selectedBackgroundImageExists )
      {
//        TR.style.backgroundColor = "inherit" ;
        TR.style.backgroundImage = "none" ;
      }
      var ev = new TEvent ( null, TEvent.prototype.ITEM_DESELECTED ) ;
      ev.setPeer ( this ) ;
      ev.setHtmlSource ( this.TABLE ) ;
      this.fireItemEvent ( ev ) ;
      if ( fireSelectionEvent ) this.fireSelectionEvent ( ev ) ;
    }
  },
  _textareaOkMouseDown: function ( event )
  {
  },
  _textareaCancelMouseDown: function ( event )
  {
    this.currentTextArea.nosave = true ;
  },
  _editableComponentStateChanged: function ( event )
  {
    var ev = new TEvent ( event ) ;
    if ( event.type == 'blur' )
    {
    }
    else
    if ( ev.isEnter() && ev.isCtrl() ) {}
    else
    if ( event.type == 'keydown' && ev.isEscape() )
    {
      this._saveCurrentTextArea ( false ) ;
      return ;
    }
    else
    if ( event.type == 'mouseup' )
    {
      return ;
    }
    else
    {
      return ;
    }
    this._saveCurrentTextArea ( true ) ;
  },
  _saveCurrentTextArea: function ( save )
  {
    if ( this.currentTextArea.nosave ) save = false ;
    var TD = this.currentTextArea.TD ;
    this.currentTextArea.TD = null ;
    this.currentTextArea = null ;
    var str = TD.currentTextArea.value ;
    TGui.flushAttributes ( TD ) ;
    TD.currentTextArea = null ;
    while ( TD.firstChild )
    {
      TD.removeChild ( TD.firstChild ) ;
    }
    if ( save )
    {
      TD.innerHTML = str.replace ( /\n/g, "<br/>" ) ;
      this._setHeaderImages() ;
      this._setClassImagesRow() ;
      var xml = new TXml ( TD.parentNode.domRow ) ;
      xml.remove ( TD.name ) ;
      var x = xml.addCDATA ( TD.name, str ) ;
    }
    else
    {
      var xml = new TXml ( TD.parentNode.domRow ) ;
      TD.innerHTML = xml.getContent ( TD.name ) ;
    }
  },
  _editableComponentChanged: function ( event )
  {
    var ev = new TEvent ( event ) ;
    if ( ev.isCtrl() ) return ;
    if ( ev.isAlt() ) return ;
    var TR = ev.getSource() ;
    for ( ; TR ; TR = TR.parentNode )
    {
      if ( TR.nodeName.toUpperCase() == 'TR' )
      {
        TR.hasChanged = true ;
        break ;
      }
    }
    if ( ev.isTab() )
    {
      if ( ! this.selectedItem )
      {
        this._setSelected ( TR, true ) ;
      }
      else
      if ( this.selectedItem && this.selectedItem != TR )
      {
        this._setSelected ( this.selectedItem, false ) ;
        this._setSelected ( TR, true ) ;
      }
      return ;
    }
    this._hasChanged = true ;
    var ev = new TPropertyChangeEvent ( event, "EDITABLE_COMPONENT" ) ;
    var c = ev.getComponent() ;
    if ( c instanceof TChoice )
    {
      var x = new TXml ( TR.domRow ) ;
      var oldValue = x.getContent ( c.getName() ) ;
      ev.setOldValue ( oldValue ) ;
      var newValue = c.getSelectedItem() ;
      ev.setNewValue ( newValue ) ;
    }
    ev.setPeer ( this ) ;
    this.propertyChangeHandler.fireEvent ( ev ) ;
  },
  getNumberOfSelectedItems: function()
  {
    this.numberOfSelectedRows = 0 ;
    for ( var r = this.TBODY.firstChild ; r ; r = r.nextSibling )
    {
      if ( r.nodeType != DOM_ELEMENT_NODE )
      {
        continue ;
      }
      if ( r.className == "ThemeTableRowClassSelected" ) this.numberOfSelectedRows++ ;
    }
    return this.numberOfSelectedRows ;
  },
  _selectItems: function ( startRow, endRow )
  {
    this.numberOfSelectedRows = 0 ;
    var r = startRow
    while ( r )
    {
      if ( r.nodeType != DOM_ELEMENT_NODE )
      {
        r = r.nextSibling ;
        continue ;
      }
      this.numberOfSelectedRows++ ;
      r.className = this.selectedRowClassName ;
      r.selected = true ;
      if ( this.selectedBackgroundImageExists )
      {
//        TR.style.backgroundColor = "transparent" ;
        TR.style.backgroundImage = TGui.buildThemeBackgroundImageUrl ( "Selected", "background", TR.offsetWidth, TR.offsetHeight ) ;
      }
      if ( r == endRow ) break ;
      r = r.nextSibling ;
    }
  },
  _setClassImagesRow: function()
  {
    for ( var TR = this.TBODY.firstChild ; TR ; TR = TR.nextSibling )
    {
      if ( TR.nodeType != DOM_ELEMENT_NODE )
      {
        continue ;
      }
      if ( ! TR.selected ) continue ;
      if ( this.selectedBackgroundImageExists )
      {
        TR.className = this.selectedRowClassName ;
//        TR.style.backgroundColor = "transparent" ;
        TR.style.backgroundImage = TGui.buildThemeBackgroundImageUrl ( "Selected", "background", TR.offsetWidth, TR.offsetHeight ) ;
      }
      else
      {
//        TR.style.backgroundColor = "inherit" ;
        TR.style.backgroundImage = "none" ;
        TR.className = this.selectedRowClassName ;
      }
    }
  },
  getAllItems: function ( changedOnly )
  {
    var a = [] ;
    var ch = this.TBODY.firstChild ;
    var index = 0 ;
    while ( ch )
    {
      if ( ch.nodeType != DOM_ELEMENT_NODE )
      {
        ch = ch.nextSibling ;
        continue ;
      }
      if ( changedOnly && ! ch.hasChanged )
      {
        ch = ch.nextSibling ;
        continue ;
      }
//      ch.hasChanged = false ;
      a.push ( ch.domRow ) ;
      if ( this.anyEditable )
      {
        var xRow = new TXml ( ch.domRow   ) ;
        var ch1 = ch.firstChild ;
        var index  = 0 ;
        while ( ch1 )
        {
          if ( ch1.xInput )
          {
            var x = xRow.getXml ( this.columnNames[index] ) ;
            if ( ! x ) x = xRow.addXml ( this.columnNames[index] ) ;
            if ( ch1.xInput.type == 'checkbox' || ch1.xInput.type == 'radio' )
            {
              if ( ch1.xInput.checked ) x.setContent ( ch1.xInput.value ) ;
              else
              {
                if ( ch1.xInput.xDefaultValue ) x.setContent ( ch1.xInput.xDefaultValue ) ;
              }
            }
            else
            if ( ch1.xInput.type == 'select-one' )
            {
              x.setContent ( ch1.xInput.value ) ;
            }
            else
            {
              x.setContent ( ch1.xInput.value ) ;
            }
          }
          index++ ;
          ch1 = ch1.nextSibling ;
        }
      }
      ch = ch.nextSibling ;
    }
    return a ;
  },
  getSelectedRows: function()
  {
    if ( ! this.selectMultiple )
    {
      if ( ! this.selectedItem ) null ;
      return [ new TTableRow ( this, this.selectedItem ) ] ;
    }
    var ch = this.TBODY.firstChild ;
    var a = [] ;
    for ( var ch = this.TBODY.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( ch.nodeType != DOM_ELEMENT_NODE )
      {
        continue ;
      }
      if ( ch.selected )
      {
        a.push ( new TTableRow ( this, ch ) ) ;
      }
    }
    return a ;
  },
  getSelectedItems: function()
  {
    var a = [] ;
    if ( ! this.selectMultiple )
    {
      if ( this.selectedItem )
      {
        a.push ( this.selectedItem.domRow ) ;
        if ( this.anyEditable )
        {
          var xRow = new TXml ( this.selectedItem.domRow   ) ;
          var ch = this.selectedItem.firstChild ;
          var index  = 0 ;
          while ( ch )
          {
            if ( ch.xInput )
            {
              var x = xRow.getXml ( this.columnNames[index] ) ;
              if ( ! x ) x = xRow.addXml ( this.columnNames[index] ) ;
              if ( ch.xInput.type == 'checkbox' || ch.xInput.type == 'radio' )
              {
                if ( ch.xInput.checked ) x.setContent ( ch.xInput.value ) ;
                else
                {
                  if ( ch.xInput.xDefaultValue ) x.setContent ( ch.xInput.xDefaultValue ) ;
                }
              }
              else
              if ( ch.xInput.type == 'select-one' )
              {
                x.setContent ( ch.xInput.value ) ;
              }
              else
              {
                x.setContent ( ch.xInput.value ) ;
              }
            }
            index++ ;
            ch = ch.nextSibling ;
          }
        }
      }
    }
    else
    {
      var ch = this.TBODY.firstChild ;
      var index = 0 ;
      while ( ch )
      {
        if ( ch.nodeType != DOM_ELEMENT_NODE )
        {
          ch = ch.nextSibling ;
          continue ;
        }
        if ( ch.selected )
        {
          a.push ( ch.domRow ) ;
          if ( this.anyEditable )
          {
            var xRow = new TXml ( ch.domRow ) ;
            var ch1 = ch.firstChild ;
            var index  = 0 ;
            while ( ch1 )
            {
              if ( ch1.firstChild )
              {
                if ( ch1.firstChild.nodeName == 'INPUT' || ch1.firstChild.nodeName == 'SELECT' )
                {
                  var x = xRow.getXml ( this.columnNames[index] ) ;
                  if ( ! x ) x = xRow.addXml ( this.columnNames[index] ) ;
                  if ( ch1.firstChild.type == 'select-one' )
                  {
                    x.setContent ( ch1.firstChild.value ) ;
                  }
                  else
                  {
                    x.setContent ( ch1.firstChild.value ) ;
                  }
                }
              }
              index++ ;
              ch1 = ch1.nextSibling ;
            }
          }
        }
        ch = ch.nextSibling ;
      }
    }
    return a ;
  },
  fireActionEvent: function ( ev )
  {
    if ( this._flushed ) return ;
    for ( var i = 0 ; i < this.actionListener.length ; i++ )
    {
      this.actionListener[i].executeWithEvent ( ev ) ;
      if ( this._flushed ) break ;
    }
    ev.consume() ;
  },
  fireKeyEvent: function ( ev )
  {
    if ( this._flushed ) return ;
    for ( var i = 0 ; i < this.keyListener.length ; i++ )
    {
      this.keyListener[i].executeWithEvent ( ev ) ;
      if ( this._flushed ) break ;
    }
  },
  fireSelectionEvent: function ( ev )
  {
    if ( this._flushed ) return ;
    for ( var i = 0 ; i < this.selectionListener.length ; i++ )
    {
      this.selectionListener[i].executeWithEvent ( ev ) ;
      if ( this._flushed ) break ;
    }
  },
  fireItemEvent: function ( ev )
  {
    if ( this._flushed ) return ;
    for ( var i = 0 ; i < this.itemListener.length ; i++ )
    {
      this.itemListener[i].executeWithEvent ( ev ) ;
      if ( ! this.selectionListener ) break ;
      if ( this._flushed ) break ;
    }
  },
  deselectAll: function()
  {
    var TR = this.TBODY.firstChild ;
    while ( TR )
    {
      if ( TR.nodeType != DOM_ELEMENT_NODE )
      {
        TR = TR.nextSibling ;
        continue ;
      }
      if ( TR.selected )
      {
        if ( this.selectedBackgroundImageExists )
        {
//          TR.style.backgroundColor = "inherit" ;
          TR.style.backgroundImage = "none" ;
        }
        if ( TR.sectionRowIndex % 2 == 1 ) TR.className = "ThemeTableRowClassAlternate" ;
        else                               TR.className = "ThemeTableRowClass" ;
      }
      TR.selected = false ;
      TR = TR.nextSibling ;
    }
    this.selectedItem = null ;
    this.numberOfSelectedRows = 0 ;
  },
  mouseClicked: function ( event )
  {
    var ev = new TEvent ( event ) ;
  },
  mouseDoubleClicked: function ( event )
  {
    var ev = new TEvent ( event ) ;
    ev.setJsSource ( this ) ;
    ev.consume() ;
    var src = ev.getSource() ;
    if ( ! src )
    {
      ev.flush() ;
      return ;
    }
    var TD = src ;
    var TR = src.parentNode ;
    if ( ! TR )
    {
      ev.flush() ;
      return ;
    }
    if ( TR.nodeName.toUpperCase() == "TD" )
    {
      TD = TR ;
      TR = TR.parentNode ;
    }
    var tbody = TR.parentNode ;
    this.selectedColumnIndex = -1 ;

    var en = new TXEnum ( TR, "td" ) ;
    while ( en.hasNext() )
    {
      this.selectedColumnIndex++ ;
      var th = en.next() ;
      if ( th == TD )
      {
        break ;
      }
    }
    if ( tbody.nodeName.toUpperCase() == "THEAD" )
    {
      ev.flush() ;
      return ;
    }
    try
    {
      ev.setAction ( "ACTION" ) ;
      this.fireActionEvent ( ev ) ;
    }
    finally
    {
      ev.flush() ;
    }
  },
  getSelectedColumnIndex: function()
  {
    return this.selectedColumnIndex ;
  },
  getSelectedIndex: function()
  {
    return this.selectedItem ? this.selectedItem.sectionRowIndex : -1 ;
  },
  getSelectedItem: function()
  {
    return this.selectedItem ;
  },
  removeSelectedItem: function()
  {
    if ( ! this.selectedItem ) return ;
    var si = this.selectedItem ;
    this.deselectAll() ;
    this.TBODY.removeChild ( si ) ;
    this._setHeaderImages() ;
    this._setClassImagesRow() ;
  },
  getSelectedUserData: function()
  {
    return this.selectedItem ? this.selectedItem.domRow : null ;
  },
  getSelectedUserXml: function()
  {
    return this.selectedItem ? new TXml ( this.selectedItem.domRow ) : null ;
  },
  addPropertyChangeListener: function ( obj, method, propertyName )
  {
    this.propertyChangeHandler.add ( obj, method, propertyName ) ;
  },
  addItemListener: function ( self, listener )
  {
    this._addItemListener ( new TFunctionExecutor ( self, listener ) ) ;
  },
  _addItemListener: function ( functionExecutor )
  {
    if ( ! functionExecutor ) return ;
    this.itemListener.push ( functionExecutor ) ;
  },
  addKeyListener: function ( self, listener )
  {
    this._addKeyListener ( new TFunctionExecutor ( self, listener ) ) ;
  },
  _addKeyListener: function ( functionExecutor )
  {
    if ( ! functionExecutor ) return ;
    this.keyListener.push ( functionExecutor ) ;
  },
  addSelectionListener: function ( self, listener )
  {
    this._addSelectionListener ( new TFunctionExecutor ( self, listener ) ) ;
  },
  _addSelectionListener: function ( functionExecutor )
  {
    if ( ! functionExecutor ) return ;
    this.selectionListener.push ( functionExecutor ) ;
  },
  addActionListener: function ( self, listener )
  {
    this._addActionListener ( new TFunctionExecutor ( self, listener ) ) ;
  },
  _addActionListener: function ( functionExecutor )
  {
    if ( ! functionExecutor ) return ;
    this.actionListener.push ( functionExecutor ) ;
  },
  sortColumn: function ( columnIndex )
  {
//TD.xInput = eTF ;
    var hasInput = this.editable[columnIndex] ? true : false ;
    var colName = this.index2Column[columnIndex] ;
    if ( ! colName ) return ;
    var a = new Array() ;

    var allIsEmpty = true ;
    var r = this.TBODY.firstChild ;
    var i = 0 ;
    var isInt = this.columnTypes[columnIndex] == "int" || this.columnTypes[columnIndex] == "long" ;
    var isFloat = this.columnTypes[columnIndex] == "float" ;
    var isIcon = this.columnTypes[columnIndex] == "icon" ;
    while ( r )
    {
      if ( r.nodeType != DOM_ELEMENT_NODE )
      {
        r = r.nextSibling ;
        continue ;
      }
      if ( r.nodeName.toUpperCase() == "TR" )
      {
        var ud = r.domRow ;
        if ( isIcon )
        {
          a[i] = r ;
          i++ ;
          allIsEmpty = false ;
          r.tempStr = r.originalIndex ;
          r = r.nextSibling ;
          continue ;
        }
        var str = null ;
        if ( hasInput )
        {
          var i2 = 0 ;
          for ( var TD = r.firstChild ; TD ; TD = TD.nextSibling )
          {
            if ( TD.nodeType != DOM_ELEMENT_NODE ) continue ;
            if ( i2 == columnIndex )
            {
              if ( ! TD.xInput )
              {
                str = new TXml ( ud ).getContent ( colName ) ;
                break ;
	      }
              str = TD.xInput.value ;
              break ;
            }
            i2++ ;
          }
        }
        else
        if ( ud )
        {
          str = new TXml ( ud ).getContent ( colName ) ;
        }
        if ( ! str )
        {
          a[i] = r ;
          i++ ;
          r = r.nextSibling ;
          continue ;
        }
        a[i] = r ;
        i++ ;
        if ( isInt )
        {
          var ii = parseInt ( str ) ;
          if ( isNaN ( ii ) ) r.tempStr = str ;
          else                r.tempStr = ii ;
        }
        else
        if ( isFloat )
        {
          var ii = parseFloat ( str ) ;
          if ( isNaN ( ii ) ) r.tempStr = str ;
          else                r.tempStr = ii ;
        }
        else
        {
          r.tempStr = str ;
        }
        allIsEmpty = false ;
      }
      r = r.nextSibling ;
    }
    var factor = this.sortedTR.sortDirection ;
    if ( ! allIsEmpty )
    {
      a.sort ( function ( e1, e2 )
      {
        if ( typeof ( e1.tempStr ) == 'undefined' ) return factor ;
        if ( typeof ( e2.tempStr ) == 'undefined' ) return - factor ;
        if ( typeof ( e1.tempStr ) == 'string' && typeof ( e2.tempStr ) == 'string' )
        {
          return ( e1.tempStr.toUpperCase() > e2.tempStr.toUpperCase() ? factor : - factor ) ;
        }
        return ( e1.tempStr > e2.tempStr ? factor : - factor ) ;
      } );
    }
    i = 0 ;
    for ( i = 0 ; i < a.length ; i++ )
    {
      a[i].tempStr = null ;
      this.TBODY.removeChild ( a[i] ) ;
      this.TBODY.appendChild ( a[i] ) ;
      a[i] = null ;
    }
    a.length = 0 ;
  },
  getValues: function ( xml )
  {
    if ( ! xml ) xml = new TXml() ;
    var a = null ;
    if ( this.getValuesChanged ) a = this.getAllItems ( true ) ;
    else
    if ( this.getValuesAll ) a = this.getAllItems() ;
    else                      a = this.getSelectedItems() ;
    for ( var i = 0 ; i < a.length ; i++ )
    {
      xml.addDuplicate ( a[i], this.rowName ) ;
    }
    a.length = 0 ;
    return xml ;
  },
  getMappings: function ( domMappings, mappingList )
  {
    var hMap = null ;
    for ( var ch = domMappings.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( ch.nodeType != DOM_ELEMENT_NODE )
      {
        continue ;
      }
      var value = ch.getAttribute ( "value" ) ;
      var def   = ch.getAttribute ( "default" ) ;
      var fc = ch.firstChild ;
      if ( ! fc && ! def )
      {
        var str = "" ;
        if ( ! hMap )
        {
          hMap = new Array() ;
        }
        if ( typeof ( value ) == 'undefined' ) value = str ;
        hMap[value] = str ;
	mappingList.push ( value ) ;
      }
      else
      if ( fc )
      {
        var str = fc.nodeValue ;
        if ( ! hMap )
        {
          hMap = new Array() ;
        }
        if ( typeof ( value ) == 'undefined' ) value = str ;
        var str2 = TSys.translate ( str ) ;
        if ( ! str2 ) str2 = "" ;
        hMap[value] = str2 ;
	mappingList.push ( value ) ;
      }
      else
      if ( def )
      {
        if ( ! hMap )
        {
          hMap = new Array() ;
        }
        if ( typeof ( value ) == 'undefined' ) value = def ;
        hMap["value"] = value ;
        hMap["default"] = def ;
	mappingList.push ( value ) ;
      }
    }
    return hMap ;
  },
  setRefData: function ( xml )
  {
    if ( ! TSys.isObject ( xml ) ) return ;
    var dom = xml ;
    if ( dom.jsClassName == "TXml" ) dom = xml.getDom() ;
    var en = new TXEnum ( dom, DOM_ELEMENT_NODE ) ;
    while ( en.hasNext() )
    {
      var dom = en.next() ;
      var index = this.column2Index[dom.nodeName] ;
      if ( index >= 0 )
      {
        var mappingList = [] ;
        var hMap = this.getMappings ( dom, mappingList ) ;
        if ( hMap )
        {
  	  this.mappings[index] = hMap ;
  	  this.mappingLists[index] = mappingList ;
        }
      }
    }
  },
  isMandatoryOk: function()
  {
    if ( ! this.anyMandatory ) return true ;
    if ( ! this.anyEdityble ) return true ;
    var r = this.TBODY.firstChild ;
    var index = 0 ;
    while ( r )
    {
      if ( r.nodeType != DOM_ELEMENT_NODE )
      {
        r = r.nextSibling ;
        continue ;
      }
      var ch = r.firstChild ;
      while ( ch )
      {
        if ( ch.firstChild )
        {
          if ( ch.firstChild.nodeName == 'SELECT' )
          {
            if ( ! new TXml ( ch ).isMandatoryOk() ) return false ;
          }
          else
          if ( ch.firstChild.nodeName == 'INPUT' )
          {
            if ( ! new TXml ( ch ).isMandatoryOk() ) return false ;
          }
        }
        ch = ch.nextSibling ;
      }
      r = r.nextSibling ;
    }
    return true ;
  },
  addToListenerContext: function ( listenerContext )
  {
    if ( this.anyEditable )
    {
      listenerContext.addPropertyChangeListenerTo ( this ) ;
    }
    else
    {
      listenerContext.addItemListenerTo ( this ) ;
    }
  },
  findRow: function ( name, value )
  {
    if ( typeof ( value ) == 'number' ) value = String ( value ) ;
    for ( var ch = this.TBODY.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;
      var xRow = new TXml ( ch.domRow   ) ;
      if ( xRow.getContent ( name ) == value )
      {
        return new TTableRow ( this, ch ) ;
      }
    }
    return null ;
  },
  getContainer: function()
  {
    if ( ! this._container )
      this._container = new TContainer ( this.dom ) ;
    return this._container ;
  },
  getBounds: function()
  {
    return this.getContainer().getBounds() ;
  }
} ;
TTable.prototype.setPopupMenu = function ( popupMenu, popupMenuClass )
{
  this.popupMenu = popupMenu ;
  this.popupMenuClass = popupMenuClass ? popupMenuClass : PopupMenu ;
}
TTable.prototype.setVisible = function ( state )
{
  this.getContainer().setVisible ( state ) ;
}
TTable.prototype.getName = function()
{
  return this.name ;
}
TTable.prototype.getSelectedRow = function()
{
  if ( ! this.selectedItem ) return null ;
  return new TTableRow ( this, this.selectedItem ) ;
}
TTable.prototype.getFirstRow = function()
{
  return this.getRowAt ( 0 ) ;
}
TTable.prototype.getLastRow = function()
{
  return this.getRowAt ( -1 ) ;
}
TTable.prototype.getRowAt = function ( index )
{
  var n = 0 ;
  if ( index < 0 )
  {
    var TR = this.TBODY.lastChild ;
    if ( ! TR ) return null ;
    return new TTableRow ( this, TR ) ;
  }
  for ( var TR = this.TBODY.firstChild ; TR ; TR = TR.nextSibling )
  {
    if ( TR.sectionRowIndex == index ) return new TTableRow ( this, TR ) ;
  }
  return null ;
}
TTable.prototype.setColumnEditTypeRadio = function ( colIndexOrName )
{
  var index = colIndexOrName ;
  if ( typeof ( colIndexOrName ) == 'string' )
  {
    index = this.getColumnIndexByName ( colIndexOrName ) ;
  }
  if ( typeof ( index ) != 'number' ) return ;
  if ( index < 0 ) return ;
  if ( this.editable[index] == "check" || this.editable[index] == "checkbox" )
  {
    this.editable[index] = "radio" ;
  }
}
TTable.prototype.setColumnEditTypeCheckBox = function ( colIndexOrName )
{
  var index = colIndexOrName ;
  if ( typeof ( colIndexOrName ) == 'string' )
  {
    index = this.getColumnIndexByName ( colIndexOrName ) ;
  }
  if ( typeof ( index ) != 'number' ) return ;
  if ( index < 0 ) return ;
  if ( this.editable[index] == "radio" )
  {
    this.editable[index] = "check" ;
  }
}
TTable.prototype.setColumnType = function ( colIndexOrName, type )
{
  var index = colIndexOrName ;
  if ( typeof ( colIndexOrName ) == 'string' )
  {
    index = this.getColumnIndexByName ( colIndexOrName ) ;
  }
  if ( typeof ( index ) != 'number' ) return ;
  if ( index < 0 ) return ;
  this.columnTypes[index] = type ;
}
TTable.prototype.setColumnTitle = function ( colIndexOrName, title )
{
  if ( ! title ) title = "" ;
  var index = colIndexOrName ;
  if ( typeof ( colIndexOrName ) == 'string' )
  {
    index = this.getColumnIndexByName ( colIndexOrName ) ;
  }
  if ( typeof ( index ) != 'number' ) return ;
  if ( index < 0 ) return ;

  var n = 0 ;
  var TR = this.THEAD.firstChild ;
  for ( var ch = TR.firstChild ; ch ; ch = ch.nextSibling )
  {
    if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;
    if ( n == index )
    {
      ch.firstChild.nodeValue = title ;
      break ;
    }
    n++ ;
  }
/*
  this.columnTypes[index] = type ;
*/
}
TTable.prototype.getColumnIndexByName = function ( name )
{
  if ( ! name ) return -1 ;
  var index = this.column2Index[name] ;
  if ( typeof ( index ) == 'undefined' ) return -1 ;
  return index ;
}
TTable.prototype.getColumnNameByIndex = function ( index )
{
  if ( typeof ( index ) != 'number' ) return null ;
  return this.index2Column[index] ;
}
TTable.prototype.addRow = function ( row )
{
  this.insertRowAt ( row, -1 ) ;
}
TTable.prototype.insertRowAt = function ( row, index )
{
  var n = this.getNumberOfRows() ;
  if ( typeof ( index ) != 'number' ) index = -1 ;
  else
  if ( index < 0 )
  {
  }
  else
  if ( index >= n ) index = -1 ;

  var realName = this.rowName ;
  var eRow = row ;
  if ( row.jsClassName )
  {
    if ( row.jsClassName == "TXml" )
    {
      eRow = row.getDom() ;
      realName = row.getName() ;
    }
    else
    if ( row.jsClassName == "TTableRow" ) eRow = row.getDom() ;
  }
  if ( eRow.nodeName.toUpperCase() != this.rowName.toUpperCase() )
  {
    var xx = new TXml ( eRow ) ;
    var xxx = xx.getXml (this.rowName  ) ;
    if ( xxx && ! xxx.isEmpty() ) eRow = xxx.getDom() ;
  }
  this.sortedTR = null ;
  var columnValues = new Array() ;
  var columnVisibleText = new Array() ;
  var columnIsIcon = new Array() ;
  var TR = null ;

  var color = eRow.getAttribute ( "color" ) ;
  var bgcolor = eRow.getAttribute ( "background-color" ) ;
  var fontWeight = eRow.getAttribute ( "font-weight" ) ;

  TR = document.createElement ( "tr" ) ;
  TR.className = "ThemeTableRowClass" ;
  if ( color ) TR.style.color = color ;
  if ( bgcolor ) TR.style.backgroundColor = bgcolor ;
  if ( fontWeight )
  {
    TR.style.fontWeight = fontWeight ;
  }

  var editableComponents = [] ;
  var maxStrings = [] ;
  for ( var i = 0 ; i < this.columnNames.length ; i++ )
  {
    maxStrings[i] = this.columnTitles[i] ;
    editableComponents[i] = [] ;
  }
  for ( var ch = eRow.firstChild ; ch ; ch = ch.nextSibling )
  {
    if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;

    var colIndex = this.column2Index[ch.nodeName] ;
    if ( isNaN ( colIndex ) ) continue ;
    columnVisibleText[colIndex] = ch.getAttribute ( "visibleText" ) ;
    var s = null ;
    if ( ch.firstChild && ch.firstChild.nodeValue )
    {
      columnValues[colIndex] = String ( ch.firstChild.nodeValue ) ;
    }
    else
    {
      columnValues[colIndex] = "" ;
    }

    if ( ! columnValues[colIndex] && ! columnVisibleText[colIndex] )
    {
      columnVisibleText[colIndex] = "" ;
      columnValues[colIndex] = "" ;
    }
    else
    if ( ! columnValues[colIndex] )
    {
      columnValues[colIndex] = columnVisibleText[colIndex] ;
    }
    else
    if ( ! columnVisibleText[colIndex] )
    {
      columnVisibleText[colIndex] = columnValues[colIndex] ;
    }
    if ( ch.getAttribute ( "isIcon" ) )
    {
      columnIsIcon[colIndex] = true ;
      columnVisibleText[colIndex] = "  " ;
    }
    var a = this.mappings[colIndex] ;
    if ( a )
    {
      var as = a[columnVisibleText[colIndex]] ;
      if ( as ) columnVisibleText[colIndex] = as ;
    }
    if ( columnVisibleText[colIndex].length > maxStrings[colIndex].length )
    {
      maxStrings[colIndex] = columnVisibleText[colIndex] ;
    }
  }

  TR.domRow = eRow ;
  TR.domRowRealName = realName ;
  for ( var i = 0 ; i < columnValues.length ; i++ )
  {
    var TD = document.createElement ( "td" ) ;
    if ( ! columnValues[i] ) columnValues[i] = "  " ;
    if ( ! columnVisibleText[i] ) columnVisibleText[i] = "  " ;
    if ( columnIsIcon[i] )
    {
      TD.innerHTML = "<img src='" + columnValues[i] + "' />" ;
    }
    else
    if ( columnVisibleText[i].indexOf  ( '<' ) >= 0 )
    {
      TD.innerHTML = columnVisibleText[i] ;
    }
    else
    if ( columnVisibleText[i].indexOf  ( '\n' ) >= 0 )
    {
      var str = columnVisibleText[i].replace ( /\n/g, "<br/>" ) ;
      TD.innerHTML = str ;
    }
    else
    {
      if ( this.columnTypes.length > i )
      {
        if ( this.columnTypes[i] == "date" )
        {
          columnValues[i] = columnValues[i].trim() ;
          if ( ! columnValues[i] )
          {
            TD.appendChild ( document.createTextNode ( "" ) ) ;
          }
          else
          {
            TD.appendChild ( document.createTextNode ( DateUtils.formatDateShort ( DateUtils.stringToDate ( columnValues[i] ) ) ) ) ;
          }
        }
        else
        if ( this.columnTypes[i] == "datetime" )
        {
          columnValues[i] = columnValues[i].trim() ;
          if ( ! columnValues[i] )
          {
            TD.appendChild ( document.createTextNode ( "" ) ) ;
          }
          else
          {
            TD.appendChild ( document.createTextNode ( DateUtils.formatDateTimeShort ( DateUtils.stringToDate ( columnValues[i] ) ) ) ) ;
          }
        }
        else
        {
          if ( this.editable[i] )
          {
            if (  this.editable[i] == "check"
               || this.editable[i] == "checkbox"
               || this.editable[i] == "radio"
               )
            {
              var eCB = null ;
              if ( TSys.isIE() )
              {
                var type = this.editable[i] ;
                if ( type != 'radio' ) type = 'checkbox' ;

                var a = this.mappings[i] ;
                var tt = columnVisibleText[i].trim() ;
                var str = columnValues[i] ;

                var val = null ;
                var def = null ;
                var checked = "" ;
                if ( a )
                {
                  val = a["value"] ;
                  def = a["default"] ;
                  if ( tt == val ) checked = "checked" ;
                }
                if ( ! val ) val = "4" ;

//                TD.innerHTML = "<input type='" + type +"' name='" + radioAndCheckboxNames[i] + "' value='" + val + "' " + checked + " ></input>" ;
                TD.innerHTML = "<input type='" + type +"' ' value='" + val + "' " + checked + " ></input>" ;
                for ( var ee = TD.firstChild ; ee ; ee = ee.nextSibling )
                {
                  if ( ee.nodeName == 'INPUT' )
                  {
                    eCB = ee ;
                    break ;
                  }
                }
                if ( def ) eCB.xDefaultValue = def ;
              }
              else
              {
                eCB = document.createElement ( "input" ) ;
                if ( this.editable[i] == "radio" )
                {
                  eCB.type = 'radio' ;
                  eCB.xClassName = "Radio" ;
                }
                else
                {
                  eCB.type = 'checkbox' ;
                  eCB.xClassName = "Checkbox" ;
                }
                TD.appendChild ( eCB ) ;
//                eCB.name = radioAndCheckboxNames[i] ;
                var a = this.mappings[i] ;
                var tt = columnVisibleText[i].trim() ;
                var str = columnValues[i] ;
                if ( a )
                {
                  var val = a["value"] ;
                  var def = a["default"] ;
                  if ( val ) eCB.value = val ;
                  if ( def ) eCB.xDefaultValue = def ;
                  if ( tt == val ) eCB.checked = true ;
                }
                else
                {
                  eCB.value = str ;
                }
              }
              TD.xInput = eCB ;
              TGui.addEventListener ( eCB, "change", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
            }
            else
            if ( this.editable[i] == "choice" )
            {
              var eCH = document.createElement ( "SELECT" ) ;
              eCH.name = this.columnNames[i] ;
              eCH.xClassName = "Choice" ;
              TD.appendChild ( eCH ) ;
              TD.xInput = eCH ;
              eCH.className = 'ThemeChoice' ;
              eCH.mandatory = this.mandatory[i] ;
              if ( this.editableWidth[i] ) eCH.style.width = this.editableWidth[i] + "px" ;
              var a = this.mappings[i] ;
              if ( a )
              {
                var ii = 0 ;
                var ml = this.mappingLists[i] ;
                for ( var iii = 0 ; iii < ml.length ; iii++ )
                {
                  var key = ml[iii] ;
                  var val = a[key] ;
                  if ( typeof ( val ) != 'string' ) continue ;
                  if ( columnValues[i] == key )
                  {
                    eCH.options[ii++] = new Option ( val, key, true, true );
                  }
                  else
                  {
                    eCH.options[ii++] = new Option ( val, key, false, false );
                  }
                }
              }
              TGui.addEventListener ( eCH, "change", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
            }
            else
            if ( this.editable[i] == true || this.editable[i] == "text" )
            {
              var eTF = document.createElement ( "INPUT" ) ;
              editableComponents[i].push ( eTF ) ;
              eTF.type = 'text' ;
              eTF.name = this.columnNames[i] ;
              eTF.xClassName = "TextField" ;
              eTF.value = columnVisibleText[i].trim() ;
              TD.appendChild ( eTF ) ;
              TD.xInput = eTF ;
              eTF.className = 'ThemeTextField' ;
              eTF.mandatory = this.mandatory[i] ;
              if ( this.editableWidth[i] ) eTF.style.width = this.editableWidth[i] + "px" ;
              if ( eTF.mandatory ) TGui.setMandatoryDecoration ( eTF ) ;
              var tempType = this.columnTypes[i] ;
              var a  = null ;
              if ( eRow ) a  = eRow.getAttribute ( "type" ) ;
              if ( a ) tempType = a ;
              if ( tempType == "int" )
              {
                eTF.style.textAlign = 'right' ;
                eTF.xType = "int" ;
                TGui.addEventListener ( eTF, "keyup", TGui.checkInput.bindAsEventListener ( TGui ) ) ;
                if ( this.mandatory[i] ) TGui.addEventListener ( eTF, "keyup", TGui.checkMandatory ) ;
              }
              else
              if ( tempType == "float" )
              {
                TD.dir = "ltr" ;
                eTF.style.textAlign = 'right' ;
                eTF.extendedType = "float" ;
                TGui.addEventListener ( eTF, "keyup", TGui.checkInput.bindAsEventListener ( TGui ) ) ;
                if ( this.mandatory[i] ) TGui.addEventListener ( eTF, "keyup", TGui.checkMandatory ) ;
              }
              else
              if ( eTF.mandatory )
              {
                TGui.addEventListener ( eTF, "keyup", TGui.checkMandatory ) ;
              }
              TGui.addEventListener ( eTF, "keyup", this._editableComponentChanged.bindAsEventListener ( this ) ) ;
            }
          }
          else
          {
            TD.appendChild ( document.createTextNode ( columnVisibleText[i] ) ) ;
          }
        }
      }
      else
      {
        TD.appendChild ( document.createTextNode ( columnVisibleText[i] ) ) ;
      }
    }
    TR.appendChild ( TD ) ;
    TR.style.cursor = "pointer" ;
    if ( ! this.wordWrap ) TD.style.whiteSpace = "nowrap" ;
    if ( this.textAlign.length > i && this.textAlign[i] ) TD.style.textAlign = this.textAlign[i] ;
    columnValues[i] = null ;
    columnIsIcon[i] = false ;
    columnVisibleText[i] = null ;
  }
  {
    var body = document.getElementsByTagName ( "body" )[0] ;
    var span = document.createElement ( "span" ) ;
    span.style.padding = "0px" ;
    span.style.margin = "0px" ;
    body.appendChild ( span ) ;
    span.innerHTML = "&nbsp;" ;

    var first = true ;
    var fontSize = null ;
    var fontWeight = null ;
    var fontFamily = null ;
    for ( var i = 0 ; i < this.editable.length ; i++ )
    {
      if ( this.editable[i] && this.editable[i] != "choice" )
      {
        if ( ! this.columnTypes[i] && ! this.editableWidth[i] )
        {
          if ( first )
          {
            var a = editableComponents[i] ;
            if ( a[0] )
            {
              fontSize = TGui.getComputedStyle ( a[0], "font-size" ) ;
              fontWeight = TGui.getComputedStyle ( a[0], "font-weight" ) ;
              fontFamily = TGui.getComputedStyle ( a[0], "font-family" ) ;
              if ( ! fontSize ) fontSize = TGui.getComputedStyle ( span, "font-size" ) ;
              if ( ! fontWeight ) fontWeight = TGui.getComputedStyle ( span, "font-weight" ) ;
              if ( ! fontFamily ) fontFamily = TGui.getComputedStyle ( span, "font-family" ) ;
              if ( fontSize ) span.style.fontSize = fontSize ;
              if ( fontWeight ) span.style.fontWeight = fontWeight ;
              if ( fontFamily ) span.style.fontFamily = fontFamily ;
              first = false ;
            }
          }
          span.innerHTML = maxStrings[i] ;
          var w = span.offsetWidth ; //+ 2 * TGui.M_width ;
          var a = editableComponents[i] ;
          for ( var j = 0 ; j < a.length ; j++ )
          {
            a[j].style.width = w + "px" ;
            if ( fontSize ) a[j].style.fontSize = fontSize ;
            if ( fontWeight ) a[j].style.fontWeight = fontWeight ;
            if ( fontFamily ) a[j].style.fontFamily = fontFamily ;
            a[j] = null ;
          }
          a.length = 0 ;
          editableComponents[i] = null ;
        }
      }
    }
    maxStrings.length = 0 ;
    editableComponents.length = 0 ;
    body.removeChild ( span ) ;
  }
  if ( index < 0 )
  {
    if ( n % 2 == 1 ) TR.className = "ThemeTableRowClassAlternate" ;
    TR.originalIndex = n ;
    this.TBODY.appendChild ( TR ) ;
  }
  else
  {
    if ( n == 0 )
    {
      if ( n % 2 == 1 ) TR.className = "ThemeTableRowClassAlternate" ;
      TR.originalIndex = n ;
      this.TBODY.appendChild ( TR ) ;
    }
    else
    {
      var k = 0 ;
      for ( var tr = this.TBODY.firstChild ; tr ; tr = tr.nextSibling )
      {
        if ( k == index )
        {
          this.TBODY.insertBefore ( TR, tr ) ;
          break ;
        }
        k++ ;
      }
    }
    var k = 0 ;
    for ( var tr = this.TBODY.firstChild ; tr ; tr = tr.nextSibling )
    {
      if ( k % 2 == 1 ) TR.className = "ThemeTableRowClassAlternate" ;
      else              TR.className = "ThemeTableRowClass" ;
      tr.originalIndex = k ;
      k++ ;
    }
  }
  columnValues.length = 0 ;
  columnVisibleText.length = 0 ;
  columnIsIcon.length = 0 ;
  this._setHeaderImages() ;
  this._setClassImagesRow() ;
  return TR ;
}
TTable.prototype.removeAll = function ()
{
  this._hasChanged = false ;
  if ( ! this.TBODY ) return ;
  if ( this.sortedTR )
  {
    this.sortedTR.sortDirection = 0 ;
    if ( this.sortedTR.sortedTD && this.sortedTR.sortedTD.arrowImage )
    {
      this.sortedTR.sortedTD.arrowImage.style.visibility = "hidden" ;
     }
    this.sortedTR = null ;
  }

  var ch = this.TBODY.firstChild ;
  while ( ch )
  {
    var ch1 = ch.nextSibling ;
    this.TBODY.removeChild ( ch ) ;
    ch = ch1 ;
  }
  this.TABLE.style.visibility = "hidden" ;
  this.TABLE.style.visibility = "inherit" ;
}
TTable.prototype.setRowHighlighted = function ( state, TR )
{
  if ( ! state )
  {
    if ( this.highlightedRow )
    {
      this.highlightedRow.className = this.highlightedRow_className ;
    }
    this.highlightedRow = null ;
    return ;
  }
  if ( TR === this.highlightedRow ) return ;
  if ( this.highlightedRow )
  {
    this.highlightedRow.className = this.highlightedRow_className ;
  }
  this.highlightedRow = TR ;
  this.highlightedRow_className = TR.className ;
  TR.className = "ThemeTableRowClassHighlighted" ;
}
TTable.prototype.getRowFromPosition = function ( x, y )
{
  var TR = this.TBODY.firstChild ;
  if ( ! TR ) return null ;
//  var width = tr.firstChild.offsetLeft + tr.firstChild.offsetWidth ;
  var width = TR.offsetWidth ;
  if ( x > width ) return null ;
 
  var y0 = this.dom.scrollTop + TR.offsetTop ;
  y = y - TR.offsetTop ;
  for ( ; TR ; TR = TR.nextSibling )
  {
    if ( TR.offsetTop - y0 + TR.offsetHeight > y )
    {
      return new TTableRow ( this, TR ) ;
    }
  }
}
TTable.prototype.scrollToTop = function()
{
  this.dom.scrollTop = 0 ;
}
TTable.prototype.createExcel = function()
{
  var str = this.getText() ;
  while ( str.indexOf ( "<img " ) >= 0 )
  {
    var pos = str.indexOf ( "<img " ) ;
    var pos1 = str.indexOf ( ">", pos )
    str = str.substring ( 0, pos ) + str.substring ( pos1+1 ) ;
  }
  TSys.downloadGeneratedDocumentFromTable ( str, "xls" ) ;
}
TTable.prototype.createCsv = function()
{
  var str = this.getText() ;
  while ( str.indexOf ( "<img " ) >= 0 )
  {
    var pos = str.indexOf ( "<img " ) ;
    var pos1 = str.indexOf ( ">", pos )
    str = str.substring ( 0, pos ) + str.substring ( pos1+1 ) ;
  }
  TSys.downloadGeneratedDocumentFromTable ( str, "csv" ) ;
}
TTable.prototype.print = function()
{
  var str = this.getText() ;
  TSys.print ( str ) ;
}
TTable.prototype.getText = function()
{
  var str = "" ;
  if ( ! this.anyEditable )
  {
    return this.TABLE.parentNode.innerHTML ;
  }

  str += "<table class='" + this.TABLE.className + "'"
       +  " border=" + this.TABLE.border
       +  " cellspacing=" + this.TABLE.cellSpacing
       +  " cellpadding=" + this.TABLE.cellPadding
       +  ">"
       ;
  if ( this.THEAD )
  {
    str += "<thead class='" + this.THEAD.className + "'>" ;
    str += this.THEAD.innerHTML ;
    str += "</thead>" ;
  }
  str += "<tbody>" ;
  var index = 0 ;
  for ( var ch = this.TBODY.firstChild ; ch ; ch = ch.nextSibling )
  {
    if ( ch.nodeType != DOM_ELEMENT_NODE )
    {
      continue ;
    }
    str += "<tr class='" + ch.className + "'>" ;
    var index  = -1 ;
    for ( var ch1 = ch.firstChild ; ch1 ; ch1 = ch1.nextSibling )
    {
      index++ ;
      if ( ! ch1.xInput )
      {
        str += "<td class='" + ch1.className + "'>" ;
        str += ch1.innerHTML ;
        str += "</td>" ;
        continue ;
      }
      str += "<td class='" + ch1.className + "'>" ;
      if ( ch1.xInput.type == 'checkbox' || ch1.xInput.type == 'radio' )
      {
        if ( ch1.xInput.checked ) str += ch1.xInput.value ;
        else
        {
          if ( ch1.xInput.xDefaultValue ) str += ch1.xInput.xDefaultValue ;
        }
      }
      else
      if ( ch1.xInput.type == 'select-one' )
      {
        var selectedIndex = ch1.xInput.selectedIndex ;
        if ( selectedIndex < 0 )
        {
          str += "&nbsp;</td>" ;
          continue ;
        }
        str += ch1.xInput.options[selectedIndex].text ;
      }
      else
      {
        str += ch1.xInput.value ;
      }
      str += "</td>" ;
    }
    str += "</tr>" ;
  }
  str += "</tbody>" ;
  str += "</table>" ;
  return str ;
}
TTable.prototype.addDropTargetListener = function ( listener )
{
  this.dom.dndTarget.addListener ( listener ) ;
}
TTable.prototype.addDragSourceListener = function ( listener )
{
  this.dom.dndSource.addListener ( listener ) ;
}
TTable.prototype.rows = function()
{
  return new TXEnum ( this.TBODY, "TR" ) ;
}
/**
 *  @constructor
 */
var TTableRow = function ( table, TR )
{
  this.jsClassName = "TTableRow" ;
  this.table = table ;
  this.TR = TR ;
}
TTableRow.prototype =
{
  toString : function()
  {
    return "(" + this.jsClassName + ")[index=" + this.TR.sectionRowIndex + ",TR=" + this.TR + "table=" + this.table
         + "\nxml:" + this.getXml()
         + "\n]" ;
  },
  getTable: function() { return this.table ; },
  getIndex: function() { return this.TR.sectionRowIndex ; },
  getDom: function() { return this.TR.domRow ; },
  getXml: function() { return new TXml ( this.TR.domRow ) ; },
  getHtmlElement: function() { return this.TR ; },
  getCellHtmlElement: function ( indexOrName )
  {
    var index = this.table.getColumnIndexByName ( indexOrName ) ;
    if ( index < 0 ) return null ;
    for ( var ch = this.TR.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( index == 0 ) return ch ;
      index-- ;
    }
    return null ;
  },
  getCellIndexFromX: function ( x )
  {
    var index = 0 ;
    for ( var ch = this.TR.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( ch.offsetLeft <= x && x <= ch.offsetLeft + ch.offsetWidth ) return index ;
      index++ ;
    }
    return -1 ;
  },
  update: function ( xml )
  {
    if ( ! xml ) return ;
    var dom = xml ;
    if ( xml.jsClassName == "TXml" ) dom = xml.getDom() ;
    var xRow = this.getXml() ;
    for ( var ch = dom.firstChild ; ch ; ch = ch.nextSibling )
    {
      if ( ch.nodeType != DOM_ELEMENT_NODE ) continue ;
      var x = new TXml ( ch ) ;
      var name = x.getName() ;
      var xOld = xRow.ensureXml ( name ) ;
      var str = x.getContent() ;
      xOld.setContent ( str ) ;
      var index = this.table.column2Index[name] ;
      var n = 0 ;
      for ( var td = this.TR.firstChild ; td ; td = td.nextSibling )
      {
        if ( n == index )
        {
// if select input TODO
          td.innerHTML = str ;
          break ;
        }
        n++ ;
      }
    }
  },
  setVisibleOnScreen: function()
  {
    this.table.dom.scrollTop = this.TR.offsetTop ;
  },
  setChanged: function ( state )
  {
    this.TR.hasChanged = state ? true : false ;
  },
  setSelected: function ( state )
  {
    this.table._setSelected ( this.TR, state ) ;
  },
  remove: function()
  {
    if ( this.TR.sectionRowIndex == this.table.getSelectedIndex() )
    {
      this.setSelected ( false ) ;
    }
    this.table.TBODY.removeChild ( this.TR ) ;
    this.table._setHeaderImages() ;
    this.table._setClassImagesRow() ;
  },
  moveToTop: function()
  {
    this.moveTo ( 0 ) ;
  },
  moveToBottom: function()
  {
    this.moveTo ( this.table.getNumberOfRows() - 1 ) ;
  },
  moveUp: function()
  {
    if ( this.TR.sectionRowIndex == 0 ) return ;
    this.moveTo ( this.TR.sectionRowIndex - 1 ) ;
  },
  moveDown: function()
  {
    if ( this.TR.sectionRowIndex >= this.table.getNumberOfRows() ) return ;
    this.moveTo ( this.TR.sectionRowIndex + 1 ) ;
  },
  moveTo: function ( index )
  {
    if ( typeof ( index ) != 'number' )
    {
      throw "Invalid value for parameter for 'index' (" + typeof ( index ) + ")" ;
    }
    if ( index < 0 )
    {
      return ;
    }
    if ( index >= this.table.getNumberOfRows() )
    {
      return ;
    }
    if ( index == this.TR.sectionRowIndex ) return ;
    if ( this.table.getNumberOfRows() <= 1 ) return ;
    if ( index == 0 )
    {
      this.table.TBODY.removeChild ( this.TR ) ;
      this.table.TBODY.insertBefore ( this.TR, this.table.TBODY.firstChild ) ;
    }
    else
    if ( index + 1 == this.table.getNumberOfRows() )
    {
      this.table.TBODY.removeChild ( this.TR ) ;
      this.table.TBODY.appendChild ( this.TR ) ;
    }
    else
    {
      var TR = null ;
      for ( var tr = this.table.TBODY.firstChild ; tr ; tr = tr.nextSibling )
      {
        if ( tr.sectionRowIndex == index )
        {
          TR = tr ;
          break ;
        }
      }
      if ( index > this.TR.sectionRowIndex )
      {
        this.table.TBODY.removeChild ( this.TR ) ;
        this.table.TBODY.insertBefore ( this.TR, TR.nextSibling ) ;
      }
      else
      {
        this.table.TBODY.removeChild ( this.TR ) ;
        this.table.TBODY.insertBefore ( this.TR, TR ) ;
      }
    }
    var k = 0 ;
    for ( var tr = this.table.TBODY.firstChild ; tr ; tr = tr.nextSibling )
    {
      tr.originalIndex = k ;
      k++ ;
    }
  },
  setColumnVisibleText: function ( indexOrName, text )
  {
    if ( ! text ) text = "&nbsp;" ;
    var index = indexOrName ;
    if ( typeof ( indexOrName ) == 'string' )
    {
      index = this.table.getColumnIndexByName ( indexOrName ) ;
    }
    else
    if ( typeof ( indexOrName ) == 'number' )
    {
    }
    else
    {
      throw "Invalid value for parameter for 'indexOrName' (" + typeof ( indexOrNamen ) + ")" ;
    }
    var n = 0 ;
    for ( var td = this.TR.firstChild ; td ; td = td.nextSibling )
    {
      if ( n == index )
      {
        td.innerHTML = text ;
        break ;
      }
      n++ ;
    }
    this.table._setHeaderImages() ;
    this.table._setClassImagesRow() ;
  },
  setHighlighted: function ( state )
  {
    this.table.setRowHighlighted ( state, this.TR ) ;
  }
}
